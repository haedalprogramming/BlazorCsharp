# JS 기초

## 목차
- [JS 기초](#js-기초)
  - [목차](#목차)
  - [JavaScript - Overview](#javascript---overview)
    - [JavaScript란 무엇인가?](#javascript란-무엇인가)
    - [클라이언트 측 JavaScript](#클라이언트-측-javascript)
    - [JavaScript의 장점](#javascript의-장점)
    - [JavaScript의 한계](#javascript의-한계)
    - [JavaScript 개발 도구](#javascript-개발-도구)
    - [오늘날의 JavaScript는 어디에 있는가?](#오늘날의-javascript는-어디에-있는가)
  - [JavaScript - Syntax](#javascript---syntax)
    - [첫 번째 JavaScript 코드](#첫-번째-javascript-코드)
    - [공백과 줄 바꿈](#공백과-줄-바꿈)
    - [세미콜론은 선택 사항](#세미콜론은-선택-사항)
    - [대소문자 구분](#대소문자-구분)
    - [JavaScript의 주석](#javascript의-주석)
    - [예제](#예제)
  - [Enabling JavaScript in Browsers](#enabling-javascript-in-browsers)
    - [Internet Explorer에서 JavaScript](#internet-explorer에서-javascript)
    - [Firefox에서 JavaScript](#firefox에서-javascript)
    - [Chrome에서 JavaScript](#chrome에서-javascript)
    - [Opera에서 JavaScript](#opera에서-javascript)
    - [JavaScript를 지원하지 않는 브라우저에 대한 경고](#javascript를-지원하지-않는-브라우저에-대한-경고)
  - [JavaScript - Placement in HTML File](#javascript---placement-in-html-file)
    - [`<head>...</head>` 섹션에 JavaScript 포함](#headhead-섹션에-javascript-포함)
    - [`<body>...</body>` 섹션에 JavaScript 포함](#bodybody-섹션에-javascript-포함)
    - [`<body>` 및 `<head>` 섹션에 JavaScript 포함](#body-및-head-섹션에-javascript-포함)
    - [외부 파일에 JavaScript 포함](#외부-파일에-javascript-포함)
  - [JavaScript - Variables](#javascript---variables)
    - [JavaScript 데이터 타입](#javascript-데이터-타입)
    - [JavaScript 변수](#javascript-변수)
    - [JavaScript 변수의 범위](#javascript-변수의-범위)
    - [JavaScript 변수 이름](#javascript-변수-이름)
    - [JavaScript 예약어](#javascript-예약어)
  - [JavaScript - Operators](#javascript---operators)
    - [연산자란 무엇인가?](#연산자란-무엇인가)
    - [산술 연산자](#산술-연산자)
    - [예제](#예제-1)
    - [비교 연산자](#비교-연산자)
    - [예제](#예제-2)
    - [논리 연산자](#논리-연산자)
    - [예제](#예제-3)
    - [비트 연산자](#비트-연산자)
    - [예제](#예제-4)
    - [할당 연산자](#할당-연산자)
    - [예제](#예제-5)
    - [기타 연산자](#기타-연산자)
    - [조건 연산자 (? :)](#조건-연산자--)
    - [예제](#예제-6)
    - [typeof 연산자](#typeof-연산자)
    - [예제](#예제-7)
  - [JavaScript - if...else Statement](#javascript---ifelse-statement)
    - [if-else의 흐름도](#if-else의-흐름도)
    - [의사 결정](#의사-결정)
    - [if 문](#if-문)
      - [구문](#구문)
      - [예제](#예제-8)
    - [if...else 문](#ifelse-문)
      - [구문](#구문-1)
      - [예제](#예제-9)
    - [if...else if... 문](#ifelse-if-문)
      - [구문](#구문-2)
      - [예제](#예제-10)
  - [JavaScript - Switch Case](#javascript---switch-case)
    - [흐름도](#흐름도)
    - [Switch case 구문](#switch-case-구문)
    - [예제](#예제-11)
    - [출력](#출력)
    - [출력](#출력-1)
  - [JavaScript - While Loops](#javascript---while-loops)
    - [while 루프](#while-루프)
    - [흐름도](#흐름도-1)
    - [while 루프 구문](#while-루프-구문)
    - [예제](#예제-12)
    - [출력](#출력-2)
    - [do...while 루프](#dowhile-루프)
    - [흐름도](#흐름도-2)
    - [do-while 루프 구문](#do-while-루프-구문)
    - [예제](#예제-13)
    - [출력](#출력-3)
  - [JavaScript - For Loop](#javascript---for-loop)
    - [흐름도](#흐름도-3)
    - [For 루프 구문](#for-루프-구문)
    - [예제](#예제-14)
    - [출력](#출력-4)
  - [JavaScript for...in loop](#javascript-forin-loop)
    - [구문](#구문-3)
    - [예제](#예제-15)
    - [출력](#출력-5)
  - [JavaScript - Loop Control](#javascript---loop-control)
    - [break 문](#break-문)
    - [흐름도](#흐름도-4)
    - [break 문 예제](#break-문-예제)
    - [출력](#출력-6)
    - [continue 문](#continue-문)
    - [continue 문 예제](#continue-문-예제)
    - [출력](#출력-7)
    - [레이블을 사용하여 흐름 제어](#레이블을-사용하여-흐름-제어)
    - [예제 1: break 문과 레이블 사용](#예제-1-break-문과-레이블-사용)
    - [출력](#출력-8)
    - [예제 2: continue 문과 레이블 사용](#예제-2-continue-문과-레이블-사용)
    - [출력](#출력-9)
  - [JavaScript - Functions](#javascript---functions)
    - [함수 정의](#함수-정의)
    - [구문](#구문-4)
    - [예제](#예제-16)
    - [함수 호출](#함수-호출)
    - [출력](#출력-10)
    - [함수 매개변수](#함수-매개변수)
    - [예제](#예제-17)
    - [출력](#출력-11)
    - [return 문](#return-문)
    - [예제](#예제-18)
    - [출력](#출력-12)
  - [JavaScript - Events](#javascript---events)
    - [이벤트란 무엇인가?](#이벤트란-무엇인가)
    - [onclick 이벤트 타입](#onclick-이벤트-타입)
      - [예제](#예제-19)
    - [출력](#출력-13)
    - [onsubmit 이벤트 타입](#onsubmit-이벤트-타입)
      - [예제](#예제-20)
    - [onmouseover와 onmouseout](#onmouseover와-onmouseout)
    - [출력](#출력-14)
    - [HTML 5 표준 이벤트](#html-5-표준-이벤트)
  - [JavaScript and Cookies](#javascript-and-cookies)
    - [쿠키란 무엇인가?](#쿠키란-무엇인가)
    - [작동 방식](#작동-방식)
    - [쿠키 저장하기](#쿠키-저장하기)
      - [예제](#예제-21)
    - [출력](#출력-15)
    - [쿠키 읽기](#쿠키-읽기)
      - [예제](#예제-22)
    - [쿠키 만료 날짜 설정](#쿠키-만료-날짜-설정)
      - [예제](#예제-23)
    - [출력](#출력-16)
    - [쿠키 삭제](#쿠키-삭제)
      - [예제](#예제-24)
    - [출력](#출력-17)
  - [JavaScript - Page Redirection](#javascript---page-redirection)
    - [페이지 리디렉션이란 무엇인가?](#페이지-리디렉션이란-무엇인가)
    - [페이지 리디렉션은 어떻게 작동하는가?](#페이지-리디렉션은-어떻게-작동하는가)
      - [예제 1](#예제-1)
    - [출력](#출력-18)
      - [예제 2](#예제-2)
    - [출력](#출력-19)
      - [예제 3](#예제-3)
  - [JavaScript - Dialog Boxes](#javascript---dialog-boxes)
    - [경고 대화 상자](#경고-대화-상자)
      - [예제](#예제-25)
    - [출력](#출력-20)
    - [확인 대화 상자](#확인-대화-상자)
      - [예제](#예제-26)
    - [출력](#출력-21)
    - [프롬프트 대화 상자](#프롬프트-대화-상자)
      - [예제](#예제-27)
    - [출력](#출력-22)
  - [JavaScript - Void Keyword](#javascript---void-keyword)
    - [구문](#구문-5)
    - [예제 1](#예제-1-1)
    - [출력](#출력-23)
    - [예제 2](#예제-2-1)
    - [출력](#출력-24)
    - [예제 3](#예제-3-1)
    - [출력](#출력-25)
  - [JavaScript - Page Printing](#javascript---page-printing)
    - [예제](#예제-28)
    - [출력](#출력-26)
    - [페이지 인쇄 방법](#페이지-인쇄-방법)
  - [JavaScript - Objects Overview](#javascript---objects-overview)
    - [객체 속성](#객체-속성)
    - [객체 메서드](#객체-메서드)
    - [사용자 정의 객체](#사용자-정의-객체)
    - [new 연산자](#new-연산자)
    - [Object() 생성자](#object-생성자)
      - [예제 1](#예제-1-2)
    - [출력](#출력-27)
      - [예제 2](#예제-2-2)
    - [출력](#출력-28)
    - [객체에 메서드 정의하기](#객체에-메서드-정의하기)
      - [예제](#예제-29)
    - [출력](#출력-29)
    - ['with' 키워드](#with-키워드)
    - [구문](#구문-6)
      - [예제](#예제-30)
    - [출력](#출력-30)
    - [JavaScript 네이티브 객체](#javascript-네이티브-객체)
  - [JavaScript - The Number Object](#javascript---the-number-object)
    - [구문](#구문-7)
    - [Number 속성](#number-속성)
    - [Number 메서드](#number-메서드)
  - [JavaScript - The Boolean Object](#javascript---the-boolean-object)
    - [구문](#구문-8)
    - [Boolean 속성](#boolean-속성)
    - [Boolean 메서드](#boolean-메서드)
  - [JavaScript - The Strings Object](#javascript---the-strings-object)
    - [구문](#구문-9)
    - [String 속성](#string-속성)
    - [String 메서드](#string-메서드)
    - [String HTML 래퍼](#string-html-래퍼)
  - [JavaScript - The Arrays Object](#javascript---the-arrays-object)
    - [구문](#구문-10)
    - [배열 속성](#배열-속성)
    - [배열 메서드](#배열-메서드)
  - [JavaScript - The Date Object](#javascript---the-date-object)
    - [구문](#구문-11)
    - [Date 속성](#date-속성)
    - [Date 메서드](#date-메서드)
    - [Date 정적 메서드](#date-정적-메서드)
  - [JavaScript - The Math Object](#javascript---the-math-object)
    - [구문](#구문-12)
    - [Math 속성](#math-속성)
    - [Math 메서드](#math-메서드)
  - [Regular Expressions and RegExp Object](#regular-expressions-and-regexp-object)
    - [구문](#구문-13)
    - [대괄호](#대괄호)
    - [수량자](#수량자)
    - [예제](#예제-31)
    - [리터럴 문자](#리터럴-문자)
    - [메타 문자](#메타-문자)
    - [수식어](#수식어)
    - [RegExp 속성](#regexp-속성)
    - [RegExp 메서드](#regexp-메서드)
  - [JavaScript - Document Object Model or DOM](#javascript---document-object-model-or-dom)
    - [HTML DOM](#html-dom)
    - [DOM 호환성](#dom-호환성)
  - [JavaScript - Errors \& Exceptions Handling](#javascript---errors--exceptions-handling)
    - [문법 오류](#문법-오류)
    - [런타임 오류](#런타임-오류)
    - [논리 오류](#논리-오류)
    - [try...catch...finally 문](#trycatchfinally-문)
    - [예제](#예제-32)
    - [throw 문](#throw-문)
    - [onerror() 메서드](#onerror-메서드)
  - [JavaScript - Form Validation](#javascript---form-validation)
    - [기본 검증](#기본-검증)
    - [데이터 형식 검증](#데이터-형식-검증)
    - [예제](#예제-33)
    - [기본 폼 검증](#기본-폼-검증)
    - [데이터 형식 검증](#데이터-형식-검증-1)
  - [JavaScript - Animation](#javascript---animation)
    - [수동 애니메이션](#수동-애니메이션)
    - [예제](#예제-34)
    - [자동 애니메이션](#자동-애니메이션)
    - [예제 코드](#예제-코드)
    - [마우스 이벤트를 통한 롤오버](#마우스-이벤트를-통한-롤오버)
  - [JavaScript - Multimedia](#javascript---multimedia)
    - [예제](#예제-35)
    - [플러그인 확인](#플러그인-확인)
    - [멀티미디어 제어](#멀티미디어-제어)
  - [JavaScript - Debugging](#javascript---debugging)
    - [IE에서의 오류 메시지](#ie에서의-오류-메시지)
      - [오류 아이콘](#오류-아이콘)
      - [인터넷 옵션](#인터넷-옵션)
    - [Firefox 또는 Mozilla에서의 오류 메시지](#firefox-또는-mozilla에서의-오류-메시지)
      - [오류 콘솔](#오류-콘솔)
    - [오류 알림](#오류-알림)
    - [스크립트 디버깅 방법](#스크립트-디버깅-방법)
      - [자바스크립트 유효성 검사기 사용](#자바스크립트-유효성-검사기-사용)
      - [프로그램에 디버깅 코드 추가](#프로그램에-디버깅-코드-추가)
      - [자바스크립트 디버거 사용](#자바스크립트-디버거-사용)
    - [개발자를 위한 유용한 팁](#개발자를-위한-유용한-팁)
  - [JavaScript - Image Map](#javascript---image-map)
  - [JavaScript - Browsers Compatibility](#javascript---browsers-compatibility)
    - [Navigator 속성](#navigator-속성)
    - [Navigator 메서드](#navigator-메서드)
    - [브라우저 감지](#브라우저-감지)
    - [출력](#출력-31)
  - [출처](#출처)
  - [다음](#다음)

---
## JavaScript - Overview

### JavaScript란 무엇인가?

JavaScript는 동적인 컴퓨터 프로그래밍 언어입니다. 이 언어는 가볍고, 웹 페이지의 일부로 가장 많이 사용됩니다. 이를 통해 클라이언트 측 스크립트가 사용자와 상호 작용하고 동적 페이지를 만들 수 있습니다. JavaScript는 객체 지향 기능을 갖춘 인터프리터 언어입니다.

JavaScript는 처음에 LiveScript로 알려졌지만, 넷스케이프는 Java의 인기로 인해 이름을 JavaScript로 변경했습니다. JavaScript는 1995년 넷스케이프 2.0에서 LiveScript라는 이름으로 처음 등장했습니다. 이 언어의 범용 코어는 넷스케이프, 인터넷 익스플로러 및 기타 웹 브라우저에 내장되었습니다.

ECMA-262 사양은 JavaScript 언어의 표준 버전을 정의했습니다.

JavaScript는 가볍고 인터프리터된 프로그래밍 언어입니다.
네트워크 중심 애플리케이션을 만들기 위해 설계되었습니다.
Java와 보완적이며 통합됩니다.
HTML과 보완적이며 통합됩니다.
개방적이고 크로스 플랫폼입니다.

### 클라이언트 측 JavaScript

클라이언트 측 JavaScript는 언어의 가장 일반적인 형태입니다. 스크립트는 브라우저에서 코드가 해석되기 위해 HTML 문서에 포함되거나 참조되어야 합니다.

이는 웹 페이지가 정적 HTML일 필요가 없으며, 사용자와 상호 작용하고 브라우저를 제어하며 동적으로 HTML 콘텐츠를 생성할 수 있는 프로그램을 포함할 수 있음을 의미합니다.

JavaScript 클라이언트 측 메커니즘은 전통적인 CGI 서버 측 스크립트보다 많은 이점을 제공합니다. 예를 들어, 사용자가 폼 필드에 유효한 이메일 주소를 입력했는지 확인하는 데 JavaScript를 사용할 수 있습니다.

JavaScript 코드는 사용자가 폼을 제출할 때 실행되며, 모든 항목이 유효한 경우에만 웹 서버에 제출됩니다.

JavaScript는 버튼 클릭, 링크 탐색 등 사용자가 명시적 또는 암시적으로 시작하는 동작을 트랩하는 데 사용할 수 있습니다.

### JavaScript의 장점

JavaScript를 사용하는 장점은 다음과 같습니다:

서버 상호 작용 감소 − 페이지를 서버로 보내기 전에 사용자 입력을 검증할 수 있습니다. 이는 서버 트래픽을 절약하여 서버 부하를 줄입니다.

방문자에게 즉각적인 피드백 제공 − 페이지가 다시 로드될 때까지 기다릴 필요가 없습니다.

상호 작용 증가 − 사용자가 마우스로 가리키거나 키보드로 활성화할 때 반응하는 인터페이스를 만들 수 있습니다.

더 풍부한 인터페이스 − JavaScript를 사용하여 드래그 앤 드롭 구성 요소 및 슬라이더와 같은 항목을 포함하여 사이트 방문자에게 풍부한 인터페이스를 제공할 수 있습니다.

### JavaScript의 한계

JavaScript를 완전한 프로그래밍 언어로 간주할 수는 없습니다. 다음과 같은 중요한 기능이 부족합니다:

클라이언트 측 JavaScript는 파일을 읽거나 쓸 수 없습니다. 이는 보안상의 이유로 유지됩니다.

JavaScript는 네트워킹 애플리케이션에 사용할 수 없습니다. 해당 지원이 없습니다.

JavaScript에는 멀티 스레딩 또는 멀티 프로세서 기능이 없습니다.

다시 한번, JavaScript는 가볍고 인터프리터된 프로그래밍 언어로, 정적 HTML 페이지에 상호 작용성을 구축할 수 있습니다.

### JavaScript 개발 도구

JavaScript의 주요 강점 중 하나는 비싼 개발 도구가 필요 없다는 것입니다. 단순한 텍스트 편집기(예: 메모장)로 시작할 수 있습니다. 웹 브라우저의 맥락에서 인터프리터된 언어이기 때문에 컴파일러를 구매할 필요도 없습니다.

삶을 더 쉽게 만들기 위해 여러 공급업체에서 매우 좋은 JavaScript 편집 도구를 제공하고 있습니다. 다음은 그 중 일부입니다:

Microsoft FrontPage − Microsoft는 FrontPage라는 인기 있는 HTML 편집기를 개발했습니다. FrontPage는 웹 개발자가 상호 작용하는 웹사이트를 만드는 데 도움을 주는 여러 JavaScript 도구도 제공합니다.

Macromedia Dreamweaver MX − Macromedia Dreamweaver MX는 전문 웹 개발자들 사이에서 매우 인기 있는 HTML 및 JavaScript 편집기입니다. 여러 편리한 사전 제작된 JavaScript 구성 요소를 제공하고 데이터베이스와 잘 통합되며 XHTML 및 XML과 같은 새로운 표준을 준수합니다.

Macromedia HomeSite 5 − HomeSite 5는 Macromedia에서 제공하는 인기 있는 HTML 및 JavaScript 편집기로 개인 웹사이트를 효과적으로 관리할 수 있습니다.

### 오늘날의 JavaScript는 어디에 있는가?

ECMAScript Edition 5 표준은 4년 만에 처음으로 업데이트될 것입니다. JavaScript 2.0은 ECMAScript 표준의 Edition 5를 준수하며, 두 언어의 차이는 매우 미묘합니다.

JavaScript 2.0의 사양은 다음 사이트에서 찾을 수 있습니다: https://www-archive.mozilla.org/js/language/js20-2002-04/

오늘날 넷스케이프의 JavaScript와 Microsoft's JScript는 ECMAScript 표준을 준수하지만, 두 언어 모두 표준의 일부가 아닌 기능을 지원합니다.

---
## JavaScript - Syntax

JavaScript는 웹 페이지의 `<script>...</script>` HTML 태그 내에 배치된 JavaScript 문을 사용하여 구현할 수 있습니다.

JavaScript가 포함된 `<script>` 태그는 웹 페이지 내 어디에든지 배치할 수 있지만, 일반적으로 `<head>` 태그 내에 두는 것이 좋습니다.

`<script>` 태그는 브라우저 프로그램에 이 태그 사이의 모든 텍스트를 스크립트로 해석하도록 알립니다. JavaScript의 간단한 구문은 다음과 같습니다.

```html
<script ...>
   JavaScript 코드
</script>
```

`<script>` 태그는 두 가지 중요한 속성을 가집니다:

- Language − 이 속성은 사용 중인 스크립트 언어를 지정합니다. 일반적으로 그 값은 javascript입니다. 최신 HTML (및 XHTML, 그 후속 버전)에서는 이 속성의 사용이 단계적으로 중단되었습니다.
- Type − 이 속성은 사용 중인 스크립트 언어를 나타내기 위해 이제 권장되며, 그 값은 "text/javascript"로 설정해야 합니다.

따라서 JavaScript 세그먼트는 다음과 같이 보일 것입니다:

```html
<script language = "javascript" type = "text/javascript">
   JavaScript 코드
</script>
```

### 첫 번째 JavaScript 코드

"Hello World"를 출력하는 샘플 예제를 살펴보겠습니다. JavaScript 코드를 둘러싼 선택적 HTML 주석을 추가했습니다. 이는 JavaScript를 지원하지 않는 브라우저에서 코드를 보호하기 위한 것입니다. 주석은 "//-->"로 끝납니다. 여기서 "//"는 JavaScript의 주석을 나타내므로, HTML 주석의 끝을 JavaScript 코드로 읽지 않도록 추가합니다. 다음으로, 문자열을 HTML 문서에 작성하는 `document.write` 함수를 호출합니다.

이 함수는 텍스트, HTML 또는 둘 다 작성하는 데 사용할 수 있습니다. 다음 코드를 보십시오.

```html
<html>
   <body>   
      <script language = "javascript" type = "text/javascript">
         <!--
            document.write("Hello World!")
         //-->
      </script>      
   </body>
</html>
```

이 코드는 다음과 같은 결과를 생성합니다 −

Hello World!

### 공백과 줄 바꿈

JavaScript는 JavaScript 프로그램에 나타나는 공백, 탭 및 줄 바꿈을 무시합니다. 프로그램에서 공백, 탭 및 줄 바꿈을 자유롭게 사용할 수 있으며, 코드를 읽고 이해하기 쉽게 정돈하고 들여쓰기 할 수 있습니다.

### 세미콜론은 선택 사항

JavaScript의 간단한 문은 일반적으로 C, C++ 및 Java에서와 같이 세미콜론 문자로 끝납니다. 그러나 JavaScript에서는 각 문이 별도의 줄에 배치되면 이 세미콜론을 생략할 수 있습니다. 예를 들어, 다음 코드는 세미콜론 없이 작성할 수 있습니다.

```html
<script language = "javascript" type = "text/javascript">
   <!--
      var1 = 10
      var2 = 20
   //-->
</script>
```

하지만 다음과 같이 한 줄로 작성하면 세미콜론을 사용해야 합니다 −

```html
<script language = "javascript" type = "text/javascript">
   <!--
      var1 = 10; var2 = 20;
   //-->
</script>
```

**참고** − 세미콜론을 사용하는 것은 좋은 프로그래밍 습관입니다.

### 대소문자 구분

JavaScript는 대소문자를 구분하는 언어입니다. 즉, 언어 키워드, 변수, 함수 이름 및 기타 모든 식별자는 항상 일관된 대소문자로 입력해야 합니다.

따라서 식별자 Time과 TIME은 JavaScript에서 다른 의미를 전달합니다.

**참고** − JavaScript에서 변수 및 함수 이름을 작성할 때 주의해야 합니다.

### JavaScript의 주석

JavaScript는 C 스타일과 C++ 스타일의 주석을 모두 지원합니다. 따라서 −

- `//`와 줄 끝 사이의 모든 텍스트는 주석으로 처리되어 JavaScript에서 무시됩니다.
- `/*`와 `*/` 사이의 모든 텍스트는 주석으로 처리됩니다. 이는 여러 줄에 걸칠 수 있습니다.

JavaScript는 HTML 주석 시작 시퀀스 `<!--`도 인식합니다. JavaScript는 이를 단일 줄 주석으로 처리하여 `//` 주석과 동일하게 처리합니다.

HTML 주석 닫기 시퀀스 `-->`는 JavaScript에서 인식되지 않으므로 `//-->`로 작성해야 합니다.

### 예제

다음 예제는 JavaScript에서 주석을 사용하는 방법을 보여줍니다.

```html
<script language = "javascript" type = "text/javascript">
   <!--
      // 이것은 주석입니다. C++의 주석과 유사합니다.
   
      /*
      * 이것은 JavaScript의 여러 줄 주석입니다.
      * C 프로그래밍의 주석과 매우 유사합니다.
      */
   //-->
</script>
```

---
## Enabling JavaScript in Browsers

모든 최신 브라우저에는 JavaScript에 대한 기본 지원이 포함되어 있습니다. 종종 이 지원을 수동으로 활성화하거나 비활성화해야 할 수 있습니다. 이 장에서는 Internet Explorer, Firefox, Chrome, Opera 브라우저에서 JavaScript 지원을 활성화 및 비활성화하는 절차를 설명합니다.

### Internet Explorer에서 JavaScript

다음은 Internet Explorer에서 JavaScript를 켜거나 끄는 간단한 단계입니다 −

메뉴에서 도구 → 인터넷 옵션을 선택합니다.

대화 상자에서 보안 탭을 선택합니다.

사용자 지정 수준 버튼을 클릭합니다.

스크립팅 옵션을 찾을 때까지 아래로 스크롤합니다.

활성 스크립팅 아래의 활성화 라디오 버튼을 선택합니다.

마지막으로 확인을 클릭하고 나옵니다.

Internet Explorer에서 JavaScript 지원을 비활성화하려면 활성 스크립팅 아래의 비활성화 라디오 버튼을 선택해야 합니다.

### Firefox에서 JavaScript

다음은 Firefox에서 JavaScript를 켜거나 끄는 단계입니다 −

새 탭을 열고 주소 표시줄에 about:config를 입력합니다.

경고 대화 상자가 나타납니다. "위험을 감수하겠습니다!"를 선택합니다.

브라우저의 구성 옵션 목록이 나타납니다.

검색 창에 javascript.enabled를 입력합니다.

해당 옵션의 값을 마우스 오른쪽 버튼으로 클릭하여 활성화 또는 비활성화할 수 있는 토글 옵션을 찾을 수 있습니다.

javascript.enabled가 true이면 클릭 시 false로 변경됩니다. JavaScript가 비활성화되어 있으면 클릭 시 활성화됩니다.

### Chrome에서 JavaScript

다음은 Chrome에서 JavaScript를 켜거나 끄는 단계입니다 −

브라우저 오른쪽 상단의 Chrome 메뉴를 클릭합니다.

설정을 선택합니다.

페이지 하단에서 고급 설정 표시를 클릭합니다.

개인정보 섹션에서 콘텐츠 설정 버튼을 클릭합니다.

"JavaScript" 섹션에서 "모든 사이트에서 JavaScript 실행 허용(권장)" 또는 "아무 사이트에서도 JavaScript 실행 허용 안 함"을 선택합니다.

### Opera에서 JavaScript

다음은 Opera에서 JavaScript를 켜거나 끄는 단계입니다 −

메뉴에서 도구 → 기본 설정을 선택합니다.

대화 상자에서 고급 옵션을 선택합니다.

목록에서 콘텐츠를 선택합니다.

JavaScript 사용 체크박스를 선택합니다.

마지막으로 확인을 클릭하고 나옵니다.

Opera에서 JavaScript 지원을 비활성화하려면 JavaScript 사용 체크박스를 선택하지 않아야 합니다.

### JavaScript를 지원하지 않는 브라우저에 대한 경고

JavaScript를 사용하여 중요한 작업을 수행해야 하는 경우 `<noscript>` 태그를 사용하여 사용자에게 경고 메시지를 표시할 수 있습니다.

다음과 같이 스크립트 블록 바로 뒤에 noscript 블록을 추가할 수 있습니다 −

```html
<html>
   <body>
      <script language = "javascript" type = "text/javascript">
         <!--
            document.write("Hello World!")
         //-->
      </script>
      
      <noscript>
         죄송합니다...JavaScript가 필요합니다.
      </noscript>      
   </body>
</html>
```

이제 사용자의 브라우저가 JavaScript를 지원하지 않거나 JavaScript가 활성화되어 있지 않은 경우, `<noscript>`의 메시지가 화면에 표시됩니다.

---
## JavaScript - Placement in HTML File

HTML 문서 어디에나 JavaScript 코드를 포함할 수 있는 유연성이 제공됩니다. 그러나 HTML 파일에 JavaScript를 포함하는 가장 선호되는 방법은 다음과 같습니다 −

- `<head>...</head>` 섹션에 스크립트 포함.
- `<body>...</body>` 섹션에 스크립트 포함.
- `<body>...</body>` 및 `<head>...</head>` 섹션에 스크립트 포함.
- 외부 파일에 스크립트를 작성하고 `<head>...</head>` 섹션에 포함.

다음 섹션에서는 HTML 파일에 JavaScript를 다양한 방식으로 배치하는 방법을 살펴보겠습니다.

### `<head>...</head>` 섹션에 JavaScript 포함

사용자가 어디를 클릭했을 때와 같은 이벤트에서 스크립트를 실행하려면 다음과 같이 스크립트를 `<head>`에 배치합니다 −

```html
<html>
   <head>      
      <script type = "text/javascript">
         <!--
            function sayHello() {
               alert("Hello World")
            }
         //-->
      </script>     
   </head>
   
   <body>
      <input type = "button" onclick = "sayHello()" value = "Say Hello" />
   </body>  
</html>
```

### `<body>...</body>` 섹션에 JavaScript 포함

페이지가 로드될 때 스크립트가 실행되어 페이지에 콘텐츠를 생성해야 하는 경우, 스크립트를 문서의 `<body>` 부분에 배치합니다. 이 경우 JavaScript를 사용하여 정의된 함수가 없습니다. 다음 코드를 보십시오.

```html
<html>
   <head>
   </head>
   
   <body>
      <script type = "text/javascript">
         <!--
            document.write("Hello World")
         //-->
      </script>
      
      <p>This is web page body </p>
   </body>
</html>
```

### `<body>` 및 `<head>` 섹션에 JavaScript 포함

JavaScript 코드를 `<head>`와 `<body>` 섹션에 모두 배치할 수 있습니다 −

```html
<html>
   <head>
      <script type = "text/javascript">
         <!--
            function sayHello() {
               alert("Hello World")
            }
         //-->
      </script>
   </head>
   
   <body>
      <script type = "text/javascript">
         <!--
            document.write("Hello World")
         //-->
      </script>
      
      <input type = "button" onclick = "sayHello()" value = "Say Hello" />
   </body>
</html>
```

### 외부 파일에 JavaScript 포함

JavaScript를 더 광범위하게 작업하기 시작하면 사이트의 여러 페이지에서 동일한 JavaScript 코드를 재사용하는 경우가 많습니다.

여러 HTML 파일에 동일한 코드를 유지할 필요가 없습니다. `<script>` 태그는 JavaScript를 외부 파일에 저장한 다음 HTML 파일에 포함할 수 있는 메커니즘을 제공합니다.

다음은 `<script>` 태그와 그 `src` 속성을 사용하여 외부 JavaScript 파일을 HTML 코드에 포함하는 방법을 보여줍니다.

```html
<html>
   <head>
      <script type = "text/javascript" src = "filename.js" ></script>
   </head>
   
   <body>
      .......
   </body>
</html>
```

외부 파일 소스에서 JavaScript를 사용하려면 모든 JavaScript 소스 코드를 ".js" 확장자를 가진 간단한 텍스트 파일에 작성한 다음 위와 같이 해당 파일을 포함해야 합니다.

예를 들어, 다음 내용을 `filename.js` 파일에 저장한 후 `filename.js` 파일을 포함한 HTML 파일에서 `sayHello` 함수를 사용할 수 있습니다.

```javascript
function sayHello() {
   alert("Hello World")
}
```
---
## JavaScript - Variables

### JavaScript 데이터 타입

프로그래밍 언어의 가장 기본적인 특성 중 하나는 지원하는 데이터 타입의 집합입니다. 이는 프로그래밍 언어에서 표현되고 조작될 수 있는 값의 유형입니다.

JavaScript는 세 가지 기본 데이터 타입을 사용할 수 있습니다 −

- 숫자: 예. 123, 120.50 등.
- 텍스트 문자열: 예. "이 텍스트 문자열" 등.
- 불리언: 예. true 또는 false.

JavaScript는 또한 null과 undefined라는 두 가지 사소한 데이터 타입을 정의하며, 각각 하나의 값만을 정의합니다. 이 기본 데이터 타입 외에도 JavaScript는 객체라는 복합 데이터 타입을 지원합니다. 객체에 대해서는 별도의 장에서 자세히 다룹니다.

**참고** − JavaScript는 정수 값과 부동 소수점 값을 구분하지 않습니다. JavaScript의 모든 숫자는 부동 소수점 값으로 표현됩니다. JavaScript는 IEEE 754 표준에 의해 정의된 64비트 부동 소수점 형식을 사용하여 숫자를 나타냅니다.

### JavaScript 변수

다른 많은 프로그래밍 언어와 마찬가지로 JavaScript에는 변수가 있습니다. 변수는 이름이 지정된 컨테이너로 생각할 수 있습니다. 이 컨테이너에 데이터를 넣고 컨테이너의 이름을 통해 데이터를 참조할 수 있습니다.

JavaScript 프로그램에서 변수를 사용하기 전에 변수를 선언해야 합니다. 변수는 다음과 같이 `var` 키워드를 사용하여 선언됩니다.

```html
<script type = "text/javascript">
   <!--
      var money;
      var name;
   //-->
</script>
```

다음과 같이 동일한 `var` 키워드를 사용하여 여러 변수를 선언할 수도 있습니다 −

```html
<script type = "text/javascript">
   <!--
      var money, name;
   //-->
</script>
```

변수에 값을 저장하는 것을 변수 초기화라고 합니다. 변수 초기화는 변수 생성 시점이나 해당 변수가 필요할 때 나중에 수행할 수 있습니다.

예를 들어, `money`라는 변수를 생성하고 나중에 2000.50 값을 할당할 수 있습니다. 다른 변수의 경우 초기화 시 값을 할당할 수 있습니다.

```html
<script type = "text/javascript">
   <!--
      var name = "Ali";
      var money;
      money = 2000.50;
   //-->
</script>
```

**참고** − var 키워드는 변수 선언이나 초기화에 한 번만 사용해야 합니다. 동일한 변수를 두 번 재선언하지 않아야 합니다.

JavaScript는 타입이 없는 언어입니다. 이는 JavaScript 변수가 어떤 데이터 타입의 값도 가질 수 있음을 의미합니다. 다른 많은 언어와 달리 변수 선언 시 변수에 어떤 타입의 값이 들어갈지를 JavaScript에 지정할 필요가 없습니다. 프로그램 실행 중 변수의 값 타입은 변경될 수 있으며, JavaScript가 이를 자동으로 처리합니다.

### JavaScript 변수의 범위

변수의 범위는 프로그램에서 변수가 정의된 영역입니다. JavaScript 변수는 두 가지 범위만 가집니다.

- 전역 변수 − 전역 변수는 전역 범위를 가지며 JavaScript 코드 어디에서나 정의될 수 있습니다.
- 지역 변수 − 지역 변수는 정의된 함수 내에서만 보입니다. 함수 매개변수는 항상 해당 함수에 로컬입니다.

함수 본문 내에서 지역 변수는 동일한 이름을 가진 전역 변수보다 우선합니다. 전역 변수와 동일한 이름의 지역 변수나 함수 매개변수를 선언하면 전역 변수를 효과적으로 숨깁니다. 다음 예제를 보십시오.

```html
<html>
   <body onload = checkscope();>   
      <script type = "text/javascript">
         <!--
            var myVar = "global";      // 전역 변수 선언
            function checkscope( ) {
               var myVar = "local";    // 지역 변수 선언
               document.write(myVar);
            }
         //-->
      </script>     
   </body>
</html>
```

이 코드는 다음과 같은 결과를 생성합니다 −

local

### JavaScript 변수 이름

JavaScript에서 변수를 이름 지을 때 다음 규칙을 염두에 두십시오.

- JavaScript 예약어를 변수 이름으로 사용하지 않아야 합니다. 이러한 예약어는 다음 섹션에서 언급합니다. 예를 들어, break나 boolean 변수 이름은 유효하지 않습니다.
- JavaScript 변수 이름은 숫자(0-9)로 시작해서는 안 됩니다. 문자나 밑줄 문자로 시작해야 합니다. 예를 들어, 123test는 유효하지 않은 변수 이름이지만 _123test는 유효합니다.
- JavaScript 변수 이름은 대소문자를 구분합니다. 예를 들어, Name과 name은 두 개의 다른 변수입니다.

### JavaScript 예약어

다음 표에 JavaScript의 모든 예약어 목록이 나와 있습니다. 이들은 JavaScript 변수, 함수, 메서드, 루프 레이블 또는 객체 이름으로 사용할 수 없습니다.

| abstract | else       | instanceof | switch      |
|---|---|---|---|
| boolean  | enum       | int        | synchronized|
| break    | export     | interface  | this        |
| byte     | extends    | long       | throw       |
| case     | false      | native     | throws      |
| catch    | final      | new        | transient   |
| char     | finally    | null       | true        |
| class    | float      | package    | try         |
| const    | for        | private    | typeof      |
| continue | function   | protected  | var         |
| debugger | goto       | public     | void        |
| default  | if         | return     | volatile    |
| delete   | implements | short      | while       |
| do       | import     | static     | with        |
| double   | in         | super      |             |

---
## JavaScript - Operators

### 연산자란 무엇인가?
간단한 표현식 4 + 5는 9와 같습니다. 여기서 4와 5는 피연산자라고 하고 ‘+’는 연산자라고 합니다. JavaScript는 다음과 같은 유형의 연산자를 지원합니다.

- 산술 연산자
- 비교 연산자
- 논리 (또는 관계) 연산자
- 할당 연산자
- 조건 (또는 삼항) 연산자

각 연산자를 하나씩 살펴보겠습니다.

### 산술 연산자
JavaScript는 다음과 같은 산술 연산자를 지원합니다 −

변수 A는 10을, 변수 B는 20을 보유한다고 가정합니다.

1. `+` (덧셈): 두 피연산자를 더합니다. 예: A + B는 30을 반환합니다.
2. `-` (뺄셈): 첫 번째 피연산자에서 두 번째 피연산자를 뺍니다. 예: A - B는 -10을 반환합니다.
3. `*` (곱셈): 두 피연산자를 곱합니다. 예: A * B는 200을 반환합니다.
4. `/` (나눗셈): 분자를 분모로 나눕니다. 예: B / A는 2를 반환합니다.
5. `%` (나머지): 정수 나눗셈의 나머지를 출력합니다. 예: B % A는 0을 반환합니다.
6. `++` (증가): 정수 값을 하나 증가시킵니다. 예: A++는 11을 반환합니다.
7. `--` (감소): 정수 값을 하나 감소시킵니다. 예: A--는 9를 반환합니다.

**참고** − 덧셈 연산자(+)는 숫자와 문자열 모두에 작동합니다. 예: "a" + 10은 "a10"을 반환합니다.

### 예제
다음 코드는 JavaScript에서 산술 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>
      <script type = "text/javascript">
         <!--
            var a = 33;
            var b = 10;
            var c = "Test";
            var linebreak = "<br />";
         
            document.write("a + b = ");
            result = a + b;
            document.write(result);
            document.write(linebreak);
         
            document.write("a - b = ");
            result = a - b;
            document.write(result);
            document.write(linebreak);
         
            document.write("a / b = ");
            result = a / b;
            document.write(result);
            document.write(linebreak);
         
            document.write("a % b = ");
            result = a % b;
            document.write(result);
            document.write(linebreak);
         
            document.write("a + b + c = ");
            result = a + b + c;
            document.write(result);
            document.write(linebreak);
         
            a = ++a;
            document.write("++a = ");
            result = ++a;
            document.write(result);
            document.write(linebreak);
         
            b = --b;
            document.write("--b = ");
            result = --b;
            document.write(result);
            document.write(linebreak);
         //-->
      </script>
      변수 값을 다르게 설정한 후 시도해 보세요...
   </body>
</html>
```

### 비교 연산자
JavaScript는 다음과 같은 비교 연산자를 지원합니다 −

변수 A는 10을, 변수 B는 20을 보유한다고 가정합니다.

1. `==` (같음): 두 피연산자의 값이 같은지 확인합니다. 예: (A == B)는 true가 아닙니다.
2. `!=` (다름): 두 피연산자의 값이 같은지 확인합니다. 값이 다르면 조건이 true가 됩니다. 예: (A != B)는 true입니다.
3. `>` (보다 큼): 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 큰지 확인합니다. 예: (A > B)는 true가 아닙니다.
4. `<` (보다 작음): 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작은지 확인합니다. 예: (A < B)는 true입니다.
5. `>=` (크거나 같음): 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크거나 같은지 확인합니다. 예: (A >= B)는 true가 아닙니다.
6. `<=` (작거나 같음): 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작거나 같은지 확인합니다. 예: (A <= B)는 true입니다.

### 예제
다음 코드는 JavaScript에서 비교 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>  
      <script type = "text/javascript">
         <!--
            var a = 10;
            var b = 20;
            var linebreak = "<br />";
      
            document.write("(a == b) => ");
            result = (a == b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a < b) => ");
            result = (a < b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a > b) => ");
            result = (a > b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a != b) => ");
            result = (a != b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a >= b) => ");
            result = (a >= b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a <= b) => ");
            result = (a <= b);
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      변수 값을 다르게 설정한 후 시도해 보세요...
   </body>
</html>
```

### 논리 연산자
JavaScript는 다음과 같은 논리 연산자를 지원합니다 −

변수 A는 10을, 변수 B는 20을 보유한다고 가정합니다.

1. `&&` (논리 AND): 두 피연산자가 모두 0이 아니면 조건이 true가 됩니다. 예: (A && B)는 true입니다.
2. `||` (논리 OR): 두 피연산자 중 하나라도 0이 아니면 조건이 true가 됩니다. 예: (A || B)는 true입니다.
3. `!` (논리 NOT): 피연산자의 논리 상태를 반전시킵니다. 조건이 true이면 논리 NOT 연산자는 이를 false로 만듭니다. 예: !(A && B)는 false입니다.

### 예제
다음 코드는 JavaScript에서 논리 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var a = true;
            var b = false;
            var linebreak = "<br />";
      
            document.write("(a && b) => ");
            result = (a && b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a || b) => ");
            result = (a || b);
            document.write(result);
            document.write(linebreak);
         
            document.write("!(a && b) => ");
            result = (!(a && b));
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 비트 연산자
JavaScript는 다음과 같은 비트 연산자를 지원합니다 −

변수 A는 2를, 변수 B는 3을 보유한다고 가정합니다.

1. `&` (비트 AND): 정수 인수의 각 비트에 대해 논리 AND 연산을 수행합니다. 예: (A & B)는 2입니다.
2. `|` (비트 OR): 정수 인수의 각 비트에 대해 논리 OR 연산을 수행합니다. 예: (A | B)는 3입니다.
3. `^` (비트 XOR): 정수 인수의 각 비트에 대해 배타적 OR 연산을 수행합니다. 배타적 OR은 피연산자 중 하나가 true이고 다른 하나는 true가 아닌 경우 true를 반환합니다. 예: (A ^ B)는 1입니다.
4. `~` (비트 NOT): 단항 연산자로, 피연산자의 모든 비트를 반전시킵니다. 예: (~B)는 -4입니다.
5. `<<` (왼쪽 시프트): 첫 번째 피연산자의 모든 비트를 두 번째 피연산자가 지정한 위치 수만큼 왼쪽으로 이동합니다. 새로운 비트는 0으로 채워집니다. 값을 한 위치 왼쪽으로 이동하는 것은 값을 2로 곱하는 것과 동일하며, 두 위치 이동하는 것은 4로 곱하는 것과 동일합니다. 예: (A << 1)은 4입니다.
6. `>>` (오른쪽 시프트): 왼쪽 피연산자의 값을 오른쪽 피연

산자가 지정한 비트 수만큼 이동합니다. 예: (A >> 1)은 1입니다.
7. `>>>` (0으로 채워지는 오른쪽 시프트): >> 연산자와 유사하지만, 왼쪽에 이동된 비트는 항상 0으로 채워집니다. 예: (A >>> 1)은 1입니다.

### 예제
다음 코드는 JavaScript에서 비트 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var a = 2; // 비트 표현 10
            var b = 3; // 비트 표현 11
            var linebreak = "<br />";
         
            document.write("(a & b) => ");
            result = (a & b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a | b) => ");
            result = (a | b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a ^ b) => ");
            result = (a ^ b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(~b) => ");
            result = (~b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a << b) => ");
            result = (a << b);
            document.write(result);
            document.write(linebreak);
         
            document.write("(a >> b) => ");
            result = (a >> b);
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 할당 연산자
JavaScript는 다음과 같은 할당 연산자를 지원합니다 −

1. `=` (단순 할당): 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당합니다. 예: C = A + B는 A + B의 값을 C에 할당합니다.
2. `+=` (더하기 할당): 오른쪽 피연산자를 왼쪽 피연산자에 더하고 결과를 왼쪽 피연산자에 할당합니다. 예: C += A는 C = C + A와 동일합니다.
3. `-=` (빼기 할당): 오른쪽 피연산자를 왼쪽 피연산자에서 빼고 결과를 왼쪽 피연산자에 할당합니다. 예: C -= A는 C = C - A와 동일합니다.
4. `*=` (곱하기 할당): 오른쪽 피연산자를 왼쪽 피연산자에 곱하고 결과를 왼쪽 피연산자에 할당합니다. 예: C *= A는 C = C * A와 동일합니다.
5. `/=` (나누기 할당): 왼쪽 피연산자를 오른쪽 피연산자로 나누고 결과를 왼쪽 피연산자에 할당합니다. 예: C /= A는 C = C / A와 동일합니다.
6. `%=` (나머지 할당): 두 피연산자를 사용하여 나머지를 구하고 결과를 왼쪽 피연산자에 할당합니다. 예: C %= A는 C = C % A와 동일합니다.

**참고** − 비트 연산자에 동일한 논리가 적용되므로 <<=, >>=, &=, |= 및 ^=와 같이 됩니다.

### 예제
다음 코드는 JavaScript에서 할당 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var a = 33;
            var b = 10;
            var linebreak = "<br />";
         
            document.write("a의 값 => (a = b) => ");
            result = (a = b);
            document.write(result);
            document.write(linebreak);
         
            document.write("a의 값 => (a += b) => ");
            result = (a += b);
            document.write(result);
            document.write(linebreak);
         
            document.write("a의 값 => (a -= b) => ");
            result = (a -= b);
            document.write(result);
            document.write(linebreak);
         
            document.write("a의 값 => (a *= b) => ");
            result = (a *= b);
            document.write(result);
            document.write(linebreak);
         
            document.write("a의 값 => (a /= b) => ");
            result = (a /= b);
            document.write(result);
            document.write(linebreak);
         
            document.write("a의 값 => (a %= b) => ");
            result = (a %= b);
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 기타 연산자
여기에서는 JavaScript에서 매우 유용한 두 가지 연산자인 조건 연산자(? :)와 typeof 연산자에 대해 논의합니다.

### 조건 연산자 (? :)
조건 연산자는 먼저 표현식을 true 또는 false 값으로 평가한 다음 평가 결과에 따라 두 개의 주어진 문 중 하나를 실행합니다.

### 예제
다음 코드를 사용하여 JavaScript에서 조건 연산자가 작동하는 방식을 이해해 보십시오.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var a = 10;
            var b = 20;
            var linebreak = "<br />";
         
            document.write ("((a > b) ? 100 : 200) => ");
            result = (a > b) ? 100 : 200;
            document.write(result);
            document.write(linebreak);
         
            document.write ("((a < b) ? 100 : 200) => ");
            result = (a < b) ? 100 : 200;
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### typeof 연산자
typeof 연산자는 단항 연산자로, 단일 피연산자 앞에 위치할 수 있으며, 피연산자의 데이터 타입을 나타내는 문자열을 반환합니다.

typeof 연산자는 피연산자가 숫자, 문자열 또는 불리언 값이면 "number", "string" 또는 "boolean"으로 평가됩니다.

다음은 typeof 연산자의 반환 값 목록입니다.

| 타입       | typeof가 반환하는 문자열  |
|------------|----------------------------|
| Number     | "number"                   |
| String     | "string"                   |
| Boolean    | "boolean"                  |
| Object     | "object"                   |
| Function   | "function"                 |
| Undefined  | "undefined"                |
| Null       | "object"                   |

### 예제
다음 코드는 typeof 연산자를 사용하는 방법을 보여줍니다.

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            var a = 10;
            var b = "String";
            var linebreak = "<br />";
         
            result = (typeof b == "string" ? "B는 문자열입니다" : "B는 숫자입니다");
            document.write("결과 => ");
            document.write(result);
            document.write(linebreak);
         
            result = (typeof a == "string" ? "A는 문자열입니다" : "A는 숫자입니다");
            document.write("결과 => ");
            document.write(result);
            document.write(linebreak);
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

---
## JavaScript - if...else Statement

프로그램을 작성할 때 주어진 경로 중 하나를 선택해야 하는 상황이 있을 수 있습니다. 이러한 경우 올바른 결정을 내리고 적절한 작업을 수행할 수 있도록 조건문을 사용해야 합니다.

JavaScript는 다양한 조건에 따라 다른 작업을 수행하는 데 사용되는 조건문을 지원합니다. 여기서는 if..else 문에 대해 설명하겠습니다.

### if-else의 흐름도
다음 흐름도는 if-else 문이 어떻게 작동하는지 보여줍니다.

### 의사 결정
JavaScript는 다음과 같은 형태의 if..else 문을 지원합니다 −

- if 문
- if...else 문
- if...else if... 문

### if 문
if 문은 JavaScript가 조건부로 결정을 내리고 문을 실행할 수 있게 하는 기본 제어문입니다.

#### 구문
기본 if 문의 구문은 다음과 같습니다 −

```javascript
if (expression) {
   // 표현식이 참일 때 실행할 문장들
}
```
여기서 JavaScript 표현식이 평가됩니다. 결과 값이 true이면 주어진 문장들이 실행됩니다. 표현식이 false이면 아무 문장도 실행되지 않습니다. 대부분의 경우, 결정을 내릴 때 비교 연산자를 사용할 것입니다.

#### 예제
if 문이 어떻게 작동하는지 이해하려면 다음 예제를 시도해 보십시오.

```html
<html>
   <body>     
      <script type = "text/javascript">
         <!--
            var age = 20;
         
            if( age > 18 ) {
               document.write("<b>Qualifies for driving</b>");
            }
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### if...else 문
'if...else' 문은 JavaScript가 문을 보다 제어된 방식으로 실행할 수 있게 하는 다음 형태의 제어문입니다.

#### 구문
```javascript
if (expression) {
   // 표현식이 참일 때 실행할 문장들
} else {
   // 표현식이 거짓일 때 실행할 문장들
}
```
여기서 JavaScript 표현식이 평가됩니다. 결과 값이 true이면 'if' 블록의 주어진 문장들이 실행됩니다. 표현식이 false이면 'else' 블록의 주어진 문장들이 실행됩니다.

#### 예제
JavaScript에서 if-else 문을 구현하는 방법을 배우려면 다음 코드를 시도해 보십시오.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var age = 15;
         
            if( age > 18 ) {
               document.write("<b>Qualifies for driving</b>");
            } else {
               document.write("<b>Does not qualify for driving</b>");
            }
         //-->
      </script>     
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### if...else if... 문
if...else if... 문은 여러 조건 중에서 올바른 결정을 내리기 위해 JavaScript가 사용할 수 있는 고급 형태의 if...else 문입니다.

#### 구문
if-else-if 문의 구문은 다음과 같습니다 −

```javascript
if (expression 1) {
   // 표현식 1이 참일 때 실행할 문장들
} else if (expression 2) {
   // 표현식 2가 참일 때 실행할 문장들
} else if (expression 3) {
   // 표현식 3이 참일 때 실행할 문장들
} else {
   // 어떠한 표현식도 참이 아닐 때 실행할 문장들
}
```
이 코드에는 특별한 것이 없습니다. 단지 일련의 if 문일 뿐이며, 각 if 문은 이전 문장의 else 절의 일부입니다. 조건이 참이면 문장이 실행되고, 조건이 모두 거짓이면 else 블록이 실행됩니다.

#### 예제
JavaScript에서 if-else-if 문을 구현하는 방법을 배우려면 다음 코드를 시도해 보십시오.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var book = "maths";
            if( book == "history" ) {
               document.write("<b>History Book</b>");
            } else if( book == "maths" ) {
               document.write("<b>Maths Book</b>");
            } else if( book == "economics" ) {
               document.write("<b>Economics Book</b>");
            } else {
               document.write("<b>Unknown Book</b>");
            }
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

---
## JavaScript - Switch Case

이전 장에서 설명한 대로 여러 if...else...if 문을 사용하여 다중 분기를 수행할 수 있습니다. 그러나 모든 분기가 단일 변수의 값에 의존할 때 이것이 항상 최상의 해결책은 아닙니다.

JavaScript 1.2부터는 switch 문을 사용할 수 있으며, 이 상황을 보다 효율적으로 처리할 수 있습니다.

### 흐름도
다음 흐름도는 switch-case 문이 어떻게 작동하는지 설명합니다.

### Switch case 구문
switch 문의 목적은 평가할 표현식과 표현식의 값에 따라 실행할 여러 다른 문을 제공하는 것입니다. 인터프리터는 각 경우를 표현식의 값과 비교하여 일치하는 항목을 찾습니다. 일치하는 항목이 없으면 기본 조건이 사용됩니다.

```javascript
switch (expression) {
   case condition 1: statement(s)
   break;
   
   case condition 2: statement(s)
   break;
   ...
   
   case condition n: statement(s)
   break;
   
   default: statement(s)
}
```
break 문은 특정 경우의 끝을 나타냅니다. 생략하면 인터프리터는 다음 경우의 각 문을 계속 실행합니다.

break 문에 대해서는 반복문 제어 장에서 설명하겠습니다.

### 예제
switch-case 문을 구현하려면 다음 예제를 시도해 보십시오.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var grade = 'A';
            document.write("Entering switch block<br />");
            switch (grade) {
               case 'A': document.write("Good job<br />");
               break;
            
               case 'B': document.write("Pretty good<br />");
               break;
            
               case 'C': document.write("Passed<br />");
               break;
            
               case 'D': document.write("Not so good<br />");
               break;
            
               case 'F': document.write("Failed<br />");
               break;
            
               default:  document.write("Unknown grade<br />")
            }
            document.write("Exiting switch block");
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```
### 출력
Entering switch block
Good job
Exiting switch block
변수 값을 다르게 설정한 후 시도해 보세요...

break 문은 switch-case 문에서 중요한 역할을 합니다. break 문이 없는 switch-case 문을 사용한 코드를 시도해 보십시오.

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            var grade = 'A';
            document.write("Entering switch block<br />");
            switch (grade) {
               case 'A': document.write("Good job<br />");
               case 'B': document.write("Pretty good<br />");
               case 'C': document.write("Passed<br />");
               case 'D': document.write("Not so good<br />");
               case 'F': document.write("Failed<br />");
               default: document.write("Unknown grade<br />")
            }
            document.write("Exiting switch block");
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Entering switch block
Good job
Pretty good
Passed
Not so good
Failed
Unknown grade
Exiting switch block
변수 값을 다르게 설정한 후 시도해 보세요...

---
## JavaScript - While Loops

프로그램을 작성할 때 반복해서 작업을 수행해야 하는 상황에 직면할 수 있습니다. 이러한 상황에서는 루프 문을 작성하여 코드의 줄 수를 줄일 필요가 있습니다.

JavaScript는 프로그래밍의 부담을 줄이기 위해 필요한 모든 루프를 지원합니다.

### while 루프
JavaScript에서 가장 기본적인 루프는 while 루프로, 이 장에서 설명합니다. while 루프의 목적은 표현식이 true인 동안 문이나 코드 블록을 반복해서 실행하는 것입니다. 표현식이 false가 되면 루프가 종료됩니다.

### 흐름도
while 루프의 흐름도는 다음과 같습니다 −

### while 루프 구문
JavaScript에서 while 루프의 구문은 다음과 같습니다 −

```javascript
while (expression) {
   // 표현식이 true일 때 실행할 문장들
}
```

### 예제
다음 예제를 시도하여 while 루프를 구현해 보십시오.

```html
<html>
   <body>
      <script type = "text/javascript">
         <!--
            var count = 0;
            document.write("Starting Loop ");
         
            while (count < 10) {
               document.write("Current Count : " + count + "<br />");
               count++;
            }
         
            document.write("Loop stopped!");
         //-->
      </script>
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Starting Loop
Current Count : 0
Current Count : 1
Current Count : 2
Current Count : 3
Current Count : 4
Current Count : 5
Current Count : 6
Current Count : 7
Current Count : 8
Current Count : 9
Loop stopped!
변수 값을 다르게 설정한 후 시도해 보세요...

### do...while 루프
do...while 루프는 조건 검사가 루프 끝에서 발생한다는 점을 제외하면 while 루프와 유사합니다. 이는 조건이 false인 경우에도 루프가 최소한 한 번은 실행된다는 것을 의미합니다.

### 흐름도
do-while 루프의 흐름도는 다음과 같습니다 −

### do-while 루프 구문
JavaScript에서 do-while 루프의 구문은 다음과 같습니다 −

```javascript
do {
   // 실행할 문장들;
} while (expression);
```

**참고** − do...while 루프 끝에 세미콜론을 놓치지 마십시오.

### 예제
다음 예제를 시도하여 JavaScript에서 do-while 루프를 구현하는 방법을 배우십시오.

```html
<html>
   <body>   
      <script type = "text/javascript">
         <!--
            var count = 0;
            
            document.write("Starting Loop" + "<br />");
            do {
               document.write("Current Count : " + count + "<br />");
               count++;
            }
            
            while (count < 5);
            document.write ("Loop stopped!");
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Starting Loop
Current Count : 0
Current Count : 1
Current Count : 2
Current Count : 3
Current Count : 4
Loop stopped!
변수 값을 다르게 설정한 후 시도해 보세요...

---
## JavaScript - For Loop

'for' 루프는 가장 간결한 형태의 반복문입니다. 다음의 세 가지 중요한 부분을 포함합니다 −

- 루프 초기화: 카운터를 시작 값으로 초기화합니다. 초기화 문은 루프가 시작되기 전에 실행됩니다.
- 테스트 문: 주어진 조건이 참인지 아닌지를 테스트합니다. 조건이 참이면 루프 내의 코드가 실행되고, 그렇지 않으면 루프를 벗어납니다.
- 반복 문: 카운터를 증가 또는 감소시킵니다.

이 세 가지 부분을 세미콜론으로 구분하여 한 줄에 넣을 수 있습니다.

### 흐름도
JavaScript에서 for 루프의 흐름도는 다음과 같습니다 −

### For 루프 구문
JavaScript에서 for 루프의 구문은 다음과 같습니다 −

```javascript
for (initialization; test condition; iteration statement) {
   // 테스트 조건이 참이면 실행할 문장들
}
```

### 예제
JavaScript에서 for 루프가 어떻게 작동하는지 배우려면 다음 예제를 시도해 보십시오.

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            var count;
            document.write("Starting Loop" + "<br />");
         
            for(count = 0; count < 10; count++) {
               document.write("Current Count : " + count );
               document.write("<br />");
            }         
            document.write("Loop stopped!");
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Starting Loop
Current Count : 0
Current Count : 1
Current Count : 2
Current Count : 3
Current Count : 4
Current Count : 5
Current Count : 6
Current Count : 7
Current Count : 8
Current Count : 9
Loop stopped!
변수 값을 다르게 설정한 후 시도해 보세요...

---
## JavaScript for...in loop

for...in 루프는 객체의 속성을 순회하는 데 사용됩니다. 객체에 대해 아직 논의하지 않았기 때문에 이 루프가 익숙하지 않을 수 있습니다. 하지만 JavaScript에서 객체가 어떻게 동작하는지 이해하게 되면, 이 루프가 매우 유용하다는 것을 알게 될 것입니다.

### 구문
‘for..in’ 루프의 구문은 다음과 같습니다 −

```javascript
for (variablename in object) {
   // 실행할 문장 또는 블록
}
```
각 반복에서 객체의 한 속성이 variablename에 할당되며, 이 루프는 객체의 모든 속성이 소진될 때까지 계속됩니다.

### 예제
다음 예제를 시도하여 ‘for-in’ 루프를 구현해 보십시오. 이는 웹 브라우저의 Navigator 객체를 출력합니다.

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            var aProperty;
            document.write("Navigator Object Properties<br /> ");        
            for (aProperty in navigator) {
               document.write(aProperty);
               document.write("<br />");
            }
            document.write ("Exiting from the loop!");
         //-->
      </script>      
      <p>변수를 다른 객체로 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Navigator Object Properties 
serviceWorker 
webkitPersistentStorage 
webkitTemporaryStorage 
geolocation 
doNotTrack 
onLine 
languages 
language 
userAgent 
product 
platform 
appVersion 
appName 
appCodeName 
hardwareConcurrency 
maxTouchPoints 
vendorSub 
vendor 
productSub 
cookieEnabled 
mimeTypes 
plugins 
javaEnabled 
getStorageUpdates 
getGamepads 
webkitGetUserMedia 
vibrate 
getBattery 
sendBeacon 
registerProtocolHandler 
unregisterProtocolHandler 
Exiting from the loop!
변수를 다른 객체로 설정한 후 시도해 보세요...

---
## JavaScript - Loop Control

JavaScript는 루프와 switch 문을 처리할 수 있는 완전한 제어 기능을 제공합니다. 루프의 끝에 도달하지 않고 루프를 빠져나와야 하는 상황이 있을 수 있습니다. 또한 코드 블록의 일부를 건너뛰고 루프의 다음 반복을 시작하고 싶은 상황이 있을 수도 있습니다.

이러한 모든 상황을 처리하기 위해 JavaScript는 break와 continue 문을 제공합니다. 이 문들은 각각 루프를 즉시 빠져나가거나 루프의 다음 반복을 시작하는 데 사용됩니다.

### break 문
break 문은 switch 문에서 간단히 소개된 것처럼 루프를 조기에 종료하는 데 사용되며, 중괄호를 감싸는 루프에서 벗어납니다.

### 흐름도
break 문의 흐름도는 다음과 같습니다 −

### break 문 예제
다음 예제는 while 루프에서 break 문을 사용하는 방법을 보여줍니다. x가 5에 도달하면 루프가 조기에 종료되고, 중괄호 바로 아래의 document.write(..) 문으로 이동합니다 −

```html
<html>
   <body>     
      <script type = "text/javascript">
         <!--
         var x = 1;
         document.write("Entering the loop<br /> ");
         
         while (x < 20) {
            if (x == 5) {
               break;   // 루프를 완전히 벗어남
            }
            x = x + 1;
            document.write( x + "<br />");
         }         
         document.write("Exiting the loop!<br /> ");
         //-->
      </script>
      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Entering the loop
2
3
4
5
Exiting the loop!
변수 값을 다르게 설정한 후 시도해 보세요...

### continue 문
continue 문은 인터프리터에게 즉시 루프의 다음 반복을 시작하고 남은 코드 블록을 건너뛰라고 지시합니다. continue 문이 실행되면 프로그램 흐름은 즉시 루프의 검사 표현식으로 이동하며, 조건이 true인 경우 다음 반복이 시작되고, 그렇지 않으면 루프를 벗어납니다.

### continue 문 예제
다음 예제는 while 루프에서 continue 문을 사용하는 방법을 보여줍니다. x 변수가 5에 도달하면 continue 문을 사용하여 출력을 건너뜁니다 −

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            var x = 1;
            document.write("Entering the loop<br /> ");
         
            while (x < 10) {
               x = x + 1;
               
               if (x == 5) {
                  continue;   // 루프 본문의 나머지를 건너뜀
               }
               document.write( x + "<br />");
            }         
            document.write("Exiting the loop!<br /> ");
         //-->
      </script>      
      <p>변수 값을 다르게 설정한 후 시도해 보세요...</p>
   </body>
</html>
```

### 출력
Entering the loop
2
3
4
6
7
8
9
10
Exiting the loop!
변수 값을 다르게 설정한 후 시도해 보세요...

### 레이블을 사용하여 흐름 제어
JavaScript 1.2부터, 레이블을 사용하여 break와 continue 문으로 흐름을 더 정확하게 제어할 수 있습니다. 레이블은 식별자 뒤에 콜론(:)이 붙은 형태로, 문장이나 코드 블록에 적용됩니다. break와 continue와 함께 레이블을 사용하는 방법을 이해하기 위해 두 가지 예제를 살펴보겠습니다.

**참고** − ‘continue’ 또는 ‘break’ 문과 레이블 이름 사이에는 줄 바꿈이 허용되지 않습니다. 또한, 레이블 이름과 관련 루프 사이에 다른 문장이 있어서는 안 됩니다.

### 예제 1: break 문과 레이블 사용
다음 예제는 break 문과 레이블을 사용하는 방법을 보여줍니다.

```html
<html>
   <body>      
      <script type = "text/javascript">
         <!--
            document.write("Entering the loop!<br /> ");
            outerloop:        // 레이블 이름         
            for (var i = 0; i < 5; i++) {
               document.write("Outerloop: " + i + "<br />");
               innerloop:
               for (var j = 0; j < 5; j++) {
                  if (j > 3 ) break ;           // 가장 안쪽 루프 종료
                  if (i == 2) break innerloop;  // 같은 동작 수행
                  if (i == 4) break outerloop;  // 바깥 루프 종료
                  document.write("Innerloop: " + j + " <br />");
               }
            }        
            document.write("Exiting the loop!<br /> ");
         //-->
      </script>      
   </body>
</html>
```

### 출력
Entering the loop!
Outerloop: 0
Innerloop: 0 
Innerloop: 1 
Innerloop: 2 
Innerloop: 3 
Outerloop: 1
Innerloop: 0 
Innerloop: 1 
Innerloop: 2 
Innerloop: 3 
Outerloop: 2
Outerloop: 3
Innerloop: 0 
Innerloop: 1 
Innerloop: 2 
Innerloop: 3 
Outerloop: 4
Exiting the loop!

### 예제 2: continue 문과 레이블 사용
다음 예제는 continue 문과 레이블을 사용하는 방법을 보여줍니다.

```html
<html>
   <body>
      <script type = "text/javascript">
         <!--
         document.write("Entering the loop!<br /> ");
         outerloop:     // 레이블 이름
         
         for (var i = 0; i < 3; i++) {
            document.write("Outerloop: " + i + "<br />");
            for (var j = 0; j < 5; j++) {
               if (j == 3) {
                  continue outerloop;
               }
               document.write("Innerloop: " + j + "<br />");
            }
         }
         
         document.write("Exiting the loop!<br /> ");
         //-->
      </script>
   </body>
</html>
```

### 출력
Entering the loop!
Outerloop: 0
Innerloop: 0
Innerloop: 1
Innerloop: 2
Outerloop: 1
Innerloop: 0
Innerloop: 1
Innerloop: 2
Outerloop: 2
Innerloop: 0
Innerloop: 1
Innerloop: 2
Exiting the loop!

---
## JavaScript - Functions

함수는 프로그램 어디에서나 호출할 수 있는 재사용 가능한 코드 그룹입니다. 이를 통해 동일한 코드를 반복해서 작성할 필요가 없어집니다. 함수는 모듈화된 코드를 작성하는 데 도움을 주며, 큰 프로그램을 여러 개의 작고 관리하기 쉬운 함수로 나눌 수 있게 합니다.

다른 고급 프로그래밍 언어와 마찬가지로, JavaScript도 함수로 모듈화된 코드를 작성하는 데 필요한 모든 기능을 지원합니다. 이전 장에서 alert() 및 write()와 같은 함수를 여러 번 사용한 것을 보았을 것입니다. 이러한 함수들은 핵심 JavaScript에서 한 번만 작성되었습니다.

JavaScript는 사용자 정의 함수를 작성할 수 있도록 합니다. 이 섹션에서는 JavaScript에서 사용자 정의 함수를 작성하는 방법을 설명합니다.

### 함수 정의
함수를 사용하기 전에 정의해야 합니다. JavaScript에서 함수를 정의하는 가장 일반적인 방법은 function 키워드, 고유한 함수 이름, (비어 있을 수도 있는) 매개변수 목록 및 중괄호로 둘러싸인 문장 블록을 사용하는 것입니다.

### 구문
기본 구문은 다음과 같습니다.

```html
<script type = "text/javascript">
   <!--
      function functionname(parameter-list) {
         statements
      }
   //-->
</script>
```

### 예제
다음 예제를 시도해 보십시오. 매개변수를 받지 않는 sayHello라는 함수를 정의합니다 −

```html
<script type = "text/javascript">
   <!--
      function sayHello() {
         alert("Hello there");
      }
   //-->
</script>
```

### 함수 호출
스크립트의 나중에 함수를 호출하려면 다음 코드와 같이 해당 함수의 이름을 작성하면 됩니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         function sayHello() {
            document.write ("Hello there!");
         }
      </script>
   </head>
   
   <body>
      <p>Click the following button to call the function</p>      
      <form>
         <input type = "button" onclick = "sayHello()" value = "Say Hello">
      </form>      
      <p>Use different text in write method and then try...</p>
   </body>
</html>
```

### 출력

### 함수 매개변수
지금까지 매개변수 없이 함수를 보았습니다. 그러나 함수를 호출할 때 다양한 매개변수를 전달할 수 있는 기능이 있습니다. 이러한 전달된 매개변수는 함수 내부에서 캡처할 수 있으며, 그 매개변수들에 대해 다양한 조작을 할 수 있습니다. 함수는 쉼표로 구분된 여러 매개변수를 받을 수 있습니다.

### 예제
다음 예제를 시도해 보십시오. 여기에서는 sayHello 함수를 수정하여 두 개의 매개변수를 받도록 합니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         function sayHello(name, age) {
            document.write (name + " is " + age + " years old.");
         }
      </script>      
   </head>
   
   <body>
      <p>Click the following button to call the function</p>      
      <form>
         <input type = "button" onclick = "sayHello('Zara', 7)" value = "Say Hello">
      </form>      
      <p>Use different parameters inside the function and then try...</p>
   </body>
</html>
```

### 출력

### return 문
JavaScript 함수는 선택적으로 return 문을 가질 수 있습니다. 함수에서 값을 반환하려면 이 문이 필요합니다. 이 문은 함수의 마지막 문이어야 합니다.

예를 들어, 두 숫자를 함수에 전달하고 함수가 호출 프로그램에서 그들의 곱셈 결과를 반환할 것으로 기대할 수 있습니다.

### 예제
다음 예제를 시도해 보십시오. 두 개의 매개변수를 받아 연결한 후 호출 프로그램에서 결과를 반환하는 함수를 정의합니다.

```html
<html>
   <head>  
      <script type = "text/javascript">
         function concatenate(first, last) {
            var full;
            full = first + last;
            return full;
         }
         function secondFunction() {
            var result;
            result = concatenate('Zara', 'Ali');
            document.write (result);
         }
      </script>      
   </head>
   
   <body>
      <p>Click the following button to call the function</p>      
      <form>
         <input type = "button" onclick = "secondFunction()" value = "Call Function">
      </form>      
      <p>Use different parameters inside the function and then try...</p>  
  </body>
</html>
```

### 출력

JavaScript 함수에 대해 배울 것이 많지만, 이 튜토리얼에서는 가장 중요한 개념들을 다루었습니다.

- JavaScript 중첩 함수
- JavaScript Function() 생성자
- JavaScript 함수 리터럴

---
## JavaScript - Events

### 이벤트란 무엇인가?
JavaScript와 HTML의 상호 작용은 사용자가 페이지를 조작하거나 브라우저가 페이지를 조작할 때 발생하는 이벤트를 통해 처리됩니다.

페이지가 로드될 때, 이는 이벤트라고 합니다. 사용자가 버튼을 클릭할 때도 클릭은 이벤트입니다. 다른 예로는 키를 누르기, 창 닫기, 창 크기 조정 등이 있습니다.

개발자는 이러한 이벤트를 사용하여 JavaScript 코드로 응답을 실행할 수 있으며, 이로 인해 버튼을 통해 창을 닫거나, 사용자에게 메시지를 표시하거나, 데이터를 검증하는 등 상상할 수 있는 거의 모든 유형의 응답을 실행할 수 있습니다.

이벤트는 문서 객체 모델(DOM) 레벨 3의 일부이며, 모든 HTML 요소에는 JavaScript 코드를 트리거할 수 있는 일련의 이벤트가 포함되어 있습니다.

이 작은 튜토리얼을 통해 HTML 이벤트 참조에 대해 더 잘 이해할 수 있습니다. 여기에서는 이벤트와 JavaScript 간의 관계를 이해하기 위한 몇 가지 예제를 살펴보겠습니다.

### onclick 이벤트 타입
이것은 사용자가 마우스의 왼쪽 버튼을 클릭할 때 발생하는 가장 자주 사용되는 이벤트 타입입니다. 이 이벤트 타입에 대해 유효성 검사, 경고 등을 설정할 수 있습니다.

#### 예제
다음 예제를 시도해 보십시오.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function sayHello() {
               alert("Hello World")
            }
         //-->
      </script>      
   </head>
   
   <body>
      <p>Click the following button and see result</p>      
      <form>
         <input type = "button" onclick = "sayHello()" value = "Say Hello" />
      </form>      
   </body>
</html>
```

### 출력

### onsubmit 이벤트 타입
onsubmit은 폼을 제출하려고 할 때 발생하는 이벤트입니다. 이 이벤트 타입에 대해 폼 유효성 검사를 설정할 수 있습니다.

#### 예제
다음 예제는 onsubmit을 사용하는 방법을 보여줍니다. 여기에서는 폼 데이터를 웹 서버에 제출하기 전에 validate() 함수를 호출합니다. validate() 함수가 true를 반환하면 폼이 제출되고, 그렇지 않으면 데이터가 제출되지 않습니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function validate() {
               // 모든 유효성 검사는 여기에
               .........
               return either true or false;
            }
         //-->
      </script>      
   </head>
   
   <body>   
      <form method = "POST" action = "t.cgi" onsubmit = "return validate()">
         .......
         <input type = "submit" value = "Submit" />
      </form>      
   </body>
</html>
```

### onmouseover와 onmouseout
이 두 가지 이벤트 타입은 이미지나 텍스트에 멋진 효과를 생성하는 데 도움이 됩니다. onmouseover 이벤트는 마우스를 요소 위로 가져갈 때 트리거되고, onmouseout 이벤트는 마우스를 요소 밖으로 이동할 때 트리거됩니다. 다음 예제를 시도해 보십시오.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function over() {
               document.write ("Mouse Over");
            }            
            function out() {
               document.write ("Mouse Out");
            }            
         //-->
      </script>      
   </head>
   
   <body>
      <p>Bring your mouse inside the division to see the result:</p>      
      <div onmouseover = "over()" onmouseout = "out()">
         <h2> This is inside the division </h2>
      </div>         
   </body>
</html>
```

### 출력

### HTML 5 표준 이벤트
표준 HTML 5 이벤트는 참조를 위해 여기에 나열되어 있습니다. 여기서 script는 해당 이벤트에 대해 실행할 JavaScript 함수를 나타냅니다.

| 속성             | 값         | 설명                                             |
|------------------|------------|--------------------------------------------------|
| offline          | script     | 문서가 오프라인 상태가 될 때 트리거됨            |
| onabort          | script     | 중단 이벤트가 발생할 때 트리거됨                 |
| onafterprint     | script     | 문서 인쇄 후 트리거됨                            |
| onbeforeonload   | script     | 문서 로드 전에 트리거됨                          |
| onbeforeprint    | script     | 문서 인쇄 전에 트리거됨                          |
| onblur           | script     | 창이 포커스를 잃을 때 트리거됨                   |
| oncanplay        | script     | 미디어가 재생을 시작할 수 있을 때 트리거됨       |
| oncanplaythrough | script     | 미디어가 버퍼링 없이 끝까지 재생될 때 트리거됨  |
| onchange         | script     | 요소가 변경될 때 트리거됨                        |
| onclick          | script     | 마우스 클릭 시 트리거됨                          |
| oncontextmenu    | script     | 컨텍스트 메뉴가 트리거될 때 트리거됨            |
| ondblclick       | script     | 마우스 더블 클릭 시 트리거됨                     |
| ondrag           | script     | 요소를 드래그할 때 트리거됨                      |
| ondragend        | script     | 드래그 작업이 끝날 때 트리거됨                  |
| ondragenter      | script     | 요소가 드래그 대상에 들어올 때 트리거됨         |
| ondragleave      | script     | 요소가 드래그 대상에서 떠날 때 트리거됨         |
| ondragover       | script     | 드래그 작업 시작 시 트리거됨                     |
| ondragstart      | script     | 드래그 작업 시작 시 트리거됨                     |
| ondrop           | script     | 드래그된 요소가 드롭될 때 트리거됨              |
| ondurationchange | script     | 미디어의 길이가 변경될 때 트리거됨               |
| onemptied        | script     | 미디어 리소스 요소가 갑자기 비어 있을 때 트리거됨|
| onended          | script     | 미디어 재생이 끝날 때 트리거됨                   |
| onerror          | script     | 오류가 발생할 때 트리거됨                        |
| onfocus          | script     | 창이 포커스를 얻을 때 트리거됨                   |
| onformchange     | script     | 폼이 변경될 때 트리거됨                          |
| onforminput      | script     | 폼이 사용자 입력을 받을 때 트리거됨              |
| onhaschange      | script     | 문서가 변경될 때 트리거됨                        |
| oninput          | script     | 요소가 사용자 입력을 받을 때 트리거됨            |
| oninvalid        | script     | 요소가 유효하지 않을 때 트리거됨                 |
| onkeydown        | script     | 키가 눌릴 때 트리거됨                            |
| onkeypress       | script     | 키가 눌렸다가 놓일 때 트리거됨                   |
| onkeyup          | script     | 키가 놓일 때 트리거됨                            |
| onload           | script     | 문서가 로드될 때 트리거됨                        |
| onloadeddata     | script     | 미디어 데이터가 로드될 때 트리거됨               |
| onloadedmetadata | script     | 미디어 요소의 지속 시간 및 기타 데이터가 로드될 때 트리거됨|
| onloadstart      | script     | 브라우저가 미디어 데이터를 로드하기 시작할 때 트리거됨|
| onmessage        | script     | 메시지가 트리거될 때 트리거됨                    |
| onmousedown      | script     | 마우스 버튼을 누를 때 트리거됨                   |
| onmousemove      | script     | 마우스 포인터가 움직일 때 트리거됨               |
| onmouseout       | script     | 마우스 포인터가 요소에서 나갈 때 트리거됨        |
| onmouseover      | script     | 마우스 포인터가 요소 위로 갈 때 트리거됨         |
| onmouseup        | script     | 마우스 버튼을 놓을 때 트리거됨                   |
| onmousewheel     | script     | 마우스 휠이 회전할 때 트리거됨                   |
| onoffline        | script     | 문서가 오프라인 상태가 될 때 트리거됨            |
| ononline         | script     | 문서가 온라인 상태가 될 때 트리거됨              |
| onpagehide       | script     | 창이 숨겨질 때 트리거됨                          |
| onpageshow       | script     | 창이 보일 때 트리거됨                            |
| onpause          | script     | 미디어 데이터가 일시 정지될 때 트리거됨          |
| onplay           | script     | 미디어 데이터 재생을 시작할 때 트리거됨          |
| onplaying        | script     | 미디어 데이터가 재생될 때 트리거됨               |
| onpopstate       | script     | 창의 히스토리가 변경될 때 트리거됨               |
| onprogress       | script     | 브라우저가 미디어 데이터를 가져올 때 트리거됨    |
| onratechange     | script     | 미디어 데이터의 재생 속도가 변경될 때 트리거됨   |
| onreadystatechange | script  | 준비 상태가 변경될 때 트리거됨                   |
| onredo           | script     | 문서가 다시 수행될 때 트리거됨                   |
| onresize         | script     | 창의 크기가 변경될 때 트리거됨                   |
| onscroll         | script     | 요소의 스크롤바가 스크롤될 때 트리거됨           |
| onseeked         | script     | 미디어 요소의 탐색 속성이 더 이상 true가 아닐 때 트리거됨|
| onseeking        | script     | 미디어 요소의 탐색 속성이 true일 때 트리거됨     |
| onselect         | script     | 요소가 선택될 때 트리거됨                        |
| onstalled        | script     | 미디어 데이터를 가져오는 데 오류가 있을 때 트리거됨|
| onstorage        | script     | 문서가 로드될 때 트리거됨                        |
| onsubmit         | script     | 폼이 제출될 때 트리거됨                          |
| onsuspend        | script     | 브라우저가 미디어 데이터를 가져오다가 멈출 때 트리거됨|
| ontimeupdate     | script     | 미디어 재생 위치가 변경될 때 트리거됨            |
| onundo           | script     | 문서가 실행 취소될 때 트리거됨                   |
| onunload         | script     | 사용자가 문서를 떠날 때 트리거됨                 |
| onvolumechange   | script     | 미디어 볼륨이 변경될 때, 볼륨이 음소거로 설정될 때 트리거됨|
| onwaiting        | script     | 미디어가 재생을 멈추고 재개될 것으로 예상될 때 트리거됨|

---
## JavaScript and Cookies

### 쿠키란 무엇인가?
웹 브라우저와 서버는 HTTP 프로토콜을 사용하여 통신하며, HTTP는 상태가 없는(stateless) 프로토콜입니다. 그러나 상업용 웹사이트에서는 여러 페이지에 걸쳐 세션 정보를 유지하는 것이 필요합니다. 예를 들어, 사용자가 여러 페이지에 걸쳐 등록을 완료한 후 하나의 사용자 등록을 마치게 됩니다. 하지만 모든 웹 페이지에서 사용자의 세션 정보를 어떻게 유지할 수 있을까요?

많은 상황에서 쿠키를 사용하는 것이 방문자의 경험을 개선하거나 사이트 통계를 위해 선호 사항, 구매 내역, 커미션 등을 기억하고 추적하는 가장 효율적인 방법입니다.

### 작동 방식
서버는 방문자의 브라우저에 쿠키 형태로 데이터를 보냅니다. 브라우저가 쿠키를 수락하면 쿠키는 방문자의 하드 드라이브에 평문 텍스트 레코드로 저장됩니다. 이제 방문자가 사이트의 다른 페이지에 도착하면 브라우저는 동일한 쿠키를 서버로 보내어 검색합니다. 검색되면 서버는 이전에 저장된 내용을 기억하게 됩니다.

쿠키는 5개의 가변 길이 필드로 구성된 평문 텍스트 데이터 레코드입니다 −

- Expires − 쿠키가 만료될 날짜입니다. 이 필드가 비어 있으면 방문자가 브라우저를 종료할 때 쿠키가 만료됩니다.
- Domain − 사이트의 도메인 이름입니다.
- Path − 쿠키를 설정한 디렉터리 또는 웹 페이지의 경로입니다. 쿠키를 모든 디렉터리나 페이지에서 검색하고 싶다면 이 필드를 비워 둘 수 있습니다.
- Secure − 이 필드에 "secure"라는 단어가 있으면 쿠키는 보안 서버에서만 검색할 수 있습니다. 이 필드가 비어 있으면 그러한 제한이 없습니다.
- Name=Value − 쿠키는 키-값 쌍 형태로 설정되고 검색됩니다.

쿠키는 원래 CGI 프로그래밍을 위해 설계되었습니다. 쿠키에 포함된 데이터는 웹 브라우저와 웹 서버 간에 자동으로 전송되므로 서버의 CGI 스크립트는 클라이언트에 저장된 쿠키 값을 읽고 쓸 수 있습니다.

JavaScript도 Document 객체의 cookie 속성을 사용하여 쿠키를 조작할 수 있습니다. JavaScript는 현재 웹 페이지에 적용되는 쿠키를 읽고, 생성하고, 수정하고, 삭제할 수 있습니다.

### 쿠키 저장하기
쿠키를 생성하는 가장 간단한 방법은 document.cookie 객체에 문자열 값을 할당하는 것입니다. 다음과 같이 보일 수 있습니다.

```javascript
document.cookie = "key1=value1;key2=value2;expires=date";
```
여기서 expires 속성은 선택 사항입니다. 유효한 날짜 또는 시간을 제공하면 쿠키는 지정된 날짜 또는 시간에 만료되며 이후에 쿠키 값을 접근할 수 없습니다.

**참고** − 쿠키 값에는 세미콜론, 쉼표 또는 공백이 포함될 수 없습니다. 이 때문에 값을 쿠키에 저장하기 전에 JavaScript의 escape() 함수를 사용하여 값을 인코딩할 수 있습니다. 이렇게 하면 쿠키 값을 읽을 때 대응하는 unescape() 함수를 사용해야 합니다.

#### 예제
다음을 시도해 보십시오. 입력 쿠키에 고객 이름을 설정합니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function WriteCookie() {
               if( document.myform.customer.value == "" ) {
                  alert("Enter some value!");
                  return;
               }
               cookievalue = escape(document.myform.customer.value) + ";";
               document.cookie = "name=" + cookievalue;
               document.write ("Setting Cookies : " + "name=" + cookievalue );
            }
         //-->
      </script>      
   </head>
   
   <body>      
      <form name = "myform" action = "">
         Enter name: <input type = "text" name = "customer"/>
         <input type = "button" value = "Set Cookie" onclick = "WriteCookie();"/>
      </form>   
   </body>
</html>
```

### 출력

이제 머신에 name이라는 쿠키가 설정되었습니다. 쉼표로 구분된 여러 키 = 값 쌍을 사용하여 여러 쿠키를 설정할 수 있습니다.

### 쿠키 읽기
쿠키를 읽는 것은 쿠키를 작성하는 것만큼 간단합니다. document.cookie 객체의 값이 쿠키이기 때문입니다. 따라서 쿠키에 접근하고 싶을 때마다 이 문자열을 사용할 수 있습니다. document.cookie 문자열은 세미콜론으로 구분된 name=value 쌍 목록을 유지합니다. 여기서 name은 쿠키의 이름이고 value는 해당 문자열 값입니다.

다음과 같이 문자열의 split() 함수를 사용하여 문자열을 키와 값으로 나눌 수 있습니다 −

#### 예제
다음 예제를 시도해 보십시오. 모든 쿠키를 가져옵니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function ReadCookie() {
               var allcookies = document.cookie;
               document.write ("All Cookies : " + allcookies );
               
               // 모든 쿠키 쌍을 배열에 가져옴
               cookiearray = allcookies.split(';');
               
               // 이제 이 배열에서 키-값 쌍을 가져옴
               for(var i=0; i<cookiearray.length; i++) {
                  name = cookiearray[i].split('=')[0];
                  value = cookiearray[i].split('=')[1];
                  document.write ("Key is : " + name + " and Value is : " + value);
               }
            }
         //-->
      </script>      
   </head>
   
   <body>     
      <form name = "myform" action = "">
         <p> click the following button and see the result:</p>
         <input type = "button" value = "Get Cookie" onclick = "ReadCookie()"/>
      </form>      
   </body>
</html>
```

**참고** − 여기서 length는 배열 클래스의 메소드로, 배열의 길이를 반환합니다. 배열에 대해서는 별도의 장에서 논의할 것입니다. 그때까지 이해하도록 노력해 보세요.

**참고** − 머신에 이미 설정된 다른 쿠키가 있을 수 있습니다. 위의 코드는 머신에 설정된 모든 쿠키를 표시합니다.

### 쿠키 만료 날짜 설정
쿠키의 만료 날짜를 설정하여 현재 브라우저 세션 이후에도 쿠키의 수명을 연장할 수 있습니다. 이는 쿠키 내에 만료 날짜를 설정하여 수행할 수 있습니다.

#### 예제
다음 예제를 시도해 보십시오. 쿠키의 만료 날짜를 1개월 연장하는 방법을 보여줍니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function WriteCookie() {
               var now = new Date();
               now.setMonth( now.getMonth() + 1 );
               cookievalue = escape(document.myform.customer.value) + ";"
               
               document.cookie = "name=" + cookievalue;
               document.cookie = "expires=" + now.toUTCString() + ";"
               document.write ("Setting Cookies : " + "name=" + cookievalue );
            }
         //-->
      </script>      
   </head>
   
   <body>
      <form name = "myform" action = "">
         Enter name: <input type = "text" name = "customer"/>
         <input type = "button" value = "Set Cookie" onclick = "WriteCookie()"/>
      </form>      
   </body>
</html>
```

### 출력

### 쿠키 삭제
때때로 쿠키를 삭제하여 이후의 쿠키 읽기 시도가 아무 것도 반환하지 않도록 하고 싶을 수 있습니다. 이를 위해 만료 날짜를 과거의 시간으로 설정하기만 하면 됩니다.

#### 예제
다음 예제를 시도해 보십시오. 쿠키의 만료 날짜를 현재 날짜보다 한 달 이전으로 설정하여 쿠키를 삭제하는 방법을 보여줍니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function WriteCookie() {
               var now = new Date();
               now.setMonth( now.getMonth() - 1 );
               cookievalue = escape(document.myform.customer.value) + ";"
               
               document.cookie = "name=" + cookievalue;
               document.cookie = "expires=" + now.toUTCString() + ";"
               document.write("Setting Cookies : " + "name=" + cookievalue );
            }
          //-->
      </script>      
   </head>
   
   <body>
      <form name = "myform" action = "">
         Enter name: <input type = "text" name = "customer"/>
         <input type = "button" value = "Set Cookie" onclick = "WriteCookie()"/>
      </form>      
   </body>
</html>
```

### 출력
---
## JavaScript - Page Redirection

### 페이지 리디렉션이란 무엇인가?
URL을 클릭하여 페이지 X에 도달하려고 했지만 내부적으로는 다른 페이지 Y로 이동하는 상황을 경험한 적이 있을 것입니다. 이것은 페이지 리디렉션 때문에 발생합니다. 이 개념은 JavaScript 페이지 새로 고침과는 다릅니다.

원래 페이지에서 사용자를 리디렉션하려는 여러 가지 이유가 있을 수 있습니다. 몇 가지 이유를 나열해 보겠습니다 −

- 도메인 이름이 마음에 들지 않아 새로운 도메인으로 이동하는 경우. 이러한 경우 모든 방문자를 새로운 사이트로 안내하고 싶을 수 있습니다. 여기서 이전 도메인은 유지하지만 페이지 리디렉션을 사용하여 모든 이전 도메인 방문자가 새 도메인으로 올 수 있도록 단일 페이지를 설정할 수 있습니다.
- 브라우저 버전 또는 이름 또는 다른 국가를 기반으로 다양한 페이지를 구축한 경우 서버 측 페이지 리디렉션을 사용하는 대신 클라이언트 측 페이지 리디렉션을 사용하여 사용자를 적절한 페이지로 안내할 수 있습니다.
- 검색 엔진이 이미 페이지를 색인화했을 수 있습니다. 그러나 다른 도메인으로 이동하는 동안 검색 엔진을 통해 오는 방문자를 잃고 싶지 않을 것입니다. 따라서 클라이언트 측 페이지 리디렉션을 사용할 수 있습니다. 하지만 이는 검색 엔진을 속이기 위해 사용해서는 안 되며, 이는 사이트가 차단될 수 있습니다.

### 페이지 리디렉션은 어떻게 작동하는가?
페이지 리디렉션 구현 방법은 다음과 같습니다.

#### 예제 1
클라이언트 측에서 JavaScript를 사용하여 페이지 리디렉션을 수행하는 것은 매우 간단합니다. 사이트 방문자를 새 페이지로 리디렉션하려면 헤드 섹션에 다음과 같은 한 줄을 추가하면 됩니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         <!--
            function Redirect() {
               window.location = "https://www.tutorialspoint.com";
            }
         //-->
      </script>
   </head>
   
   <body>
      <p>다음 버튼을 클릭하면 홈페이지로 리디렉션됩니다.</p>
      
      <form>
         <input type = "button" value = "Redirect Me" onclick = "Redirect();" />
      </form>
      
   </body>
</html>
```

### 출력

#### 예제 2
사이트 방문자에게 새 페이지로 리디렉션하기 전에 적절한 메시지를 표시할 수 있습니다. 이는 새 페이지를 로드하는 데 약간의 시간 지연이 필요합니다. 다음 예제는 이를 구현하는 방법을 보여줍니다. 여기서 setTimeout()은 주어진 시간 간격 후에 다른 함수를 실행하는 데 사용할 수 있는 내장 JavaScript 함수입니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         <!--
            function Redirect() {
               window.location = "https://www.tutorialspoint.com";
            }            
            document.write("10초 후에 메인 페이지로 리디렉션됩니다.");
            setTimeout('Redirect()', 10000);
         //-->
      </script>
   </head>
   
   <body>
   </body>
</html>
```

### 출력
10초 후에 tutorialspoint.com 메인 페이지로 리디렉션됩니다!

#### 예제 3
다음 예제는 사용자의 브라우저를 기반으로 사이트 방문자를 다른 페이지로 리디렉션하는 방법을 보여줍니다.

```html
<html>
   <head>     
      <script type = "text/javascript">
         <!--
            var browsername = navigator.appName;
            if( browsername == "Netscape" ) {
               window.location = "http://www.location.com/ns.htm";
            } else if ( browsername == "Microsoft Internet Explorer") {
               window.location = "http://www.location.com/ie.htm";
            } else {
               window.location = "http://www.location.com/other.htm";
            }
         //-->
      </script>      
   </head>
   
   <body>
   </body>
</html>
```
---
## JavaScript - Dialog Boxes

JavaScript는 세 가지 중요한 유형의 대화 상자를 지원합니다. 이러한 대화 상자는 경고 메시지를 표시하거나, 사용자로부터 입력을 확인하거나, 사용자의 입력을 받기 위해 사용할 수 있습니다. 여기서는 각 대화 상자를 하나씩 설명하겠습니다.

### 경고 대화 상자
경고 대화 상자는 주로 사용자에게 경고 메시지를 전달하는 데 사용됩니다. 예를 들어, 하나의 입력 필드에 텍스트를 입력해야 하는데 사용자가 입력하지 않은 경우, 유효성 검사의 일환으로 경고 상자를 사용하여 경고 메시지를 전달할 수 있습니다.

그러나 경고 상자는 더 친근한 메시지를 전달하는 데에도 사용할 수 있습니다. 경고 상자는 "확인" 버튼 하나만 제공하여 선택하고 진행할 수 있습니다.

#### 예제
```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function Warn() {
               alert("This is a warning message!");
               document.write("This is a warning message!");
            }
         //-->
      </script>     
   </head>
   
   <body>
      <p>결과를 보려면 다음 버튼을 클릭하세요:</p>      
      <form>
         <input type = "button" value = "Click Me" onclick = "Warn();" />
      </form>     
   </body>
</html>
```

### 출력

### 확인 대화 상자
확인 대화 상자는 주로 사용자의 동의를 얻기 위해 사용됩니다. 이 대화 상자는 "확인"과 "취소" 두 개의 버튼이 있는 대화 상자를 표시합니다.

사용자가 "확인" 버튼을 클릭하면 window 메서드 confirm()이 true를 반환합니다. 사용자가 "취소" 버튼을 클릭하면 confirm()은 false를 반환합니다. 다음과 같이 확인 대화 상자를 사용할 수 있습니다.

#### 예제
```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
            function getConfirmation() {
               var retVal = confirm("Do you want to continue?");
               if(retVal == true) {
                  document.write("User wants to continue!");
                  return true;
               } else {
                  document.write("User does not want to continue!");
                  return false;
               }
            }
         //-->
      </script>     
   </head>
   
   <body>
      <p>결과를 보려면 다음 버튼을 클릭하세요:</p>      
      <form>
         <input type = "button" value = "Click Me" onclick = "getConfirmation();" />
      </form>      
   </body>
</html>
```

### 출력

### 프롬프트 대화 상자
프롬프트 대화 상자는 사용자 입력을 받기 위해 텍스트 상자를 팝업하려는 경우 매우 유용합니다. 이를 통해 사용자와 상호 작용할 수 있습니다. 사용자는 필드를 작성한 후 "확인"을 클릭해야 합니다.

이 대화 상자는 prompt()라는 메서드를 사용하여 표시되며, 이 메서드는 두 개의 매개변수를 받습니다: (i) 텍스트 상자에 표시할 레이블, (ii) 텍스트 상자에 표시할 기본 문자열.

이 대화 상자는 "확인"과 "취소" 두 개의 버튼을 가지고 있습니다. 사용자가 "확인" 버튼을 클릭하면 window 메서드 prompt()는 텍스트 상자에 입력된 값을 반환합니다. 사용자가 "취소" 버튼을 클릭하면 window 메서드 prompt()는 null을 반환합니다.

#### 예제
다음 예제는 프롬프트 대화 상자를 사용하는 방법을 보여줍니다 −

```html
<html>
   <head>     
      <script type = "text/javascript">
         <!--
            function getValue() {
               var retVal = prompt("Enter your name: ", "your name here");
               document.write("You have entered: " + retVal);
            }
         //-->
      </script>      
   </head>
   
   <body>
      <p>결과를 보려면 다음 버튼을 클릭하세요:</p>      
      <form>
         <input type = "button" value = "Click Me" onclick = "getValue();" />
      </form>      
   </body>
</html>
```

### 출력
---

## JavaScript - Void Keyword

`void`는 JavaScript에서 중요한 키워드로, 단항 연산자로 사용되어 단일 피연산자 앞에 나타날 수 있습니다. 이 연산자는 값을 반환하지 않고 표현식을 평가하도록 지정합니다.

### 구문
`void`의 구문은 다음 두 가지 중 하나일 수 있습니다.

```html
<head>
   <script type = "text/javascript">
      <!--
         void func()
         javascript:void func()
         or:
         void(func())
         javascript:void(func())
      //-->
   </script>
</head>
```

### 예제 1
이 연산자의 가장 일반적인 사용은 클라이언트 측 `javascript:` URL에서, 브라우저가 평가된 표현식의 값을 표시하지 않고 부작용을 평가할 수 있게 하는 것입니다.

여기서 표현식 `alert ('Warning!!!')`는 평가되지만 현재 문서에 다시 로드되지 않습니다.

```html
<html>
   <head>      
      <script type = "text/javascript">
         <!--
         //-->
      </script>   
   </head>
   
   <body>   
      <p>다음을 클릭하세요. 전혀 반응하지 않을 것입니다...</p>
      <a href = "javascript:void(alert('Warning!!!'))">Click me!</a>     
   </body>
</html>
```

### 출력

### 예제 2
다음 예제를 살펴보십시오. 다음 링크는 아무 것도 하지 않습니다. 왜냐하면 표현식 "0"은 JavaScript에서 아무런 효과가 없기 때문입니다. 여기서 표현식 "0"은 평가되지만 현재 문서에 다시 로드되지 않습니다.

```html
<html>
   <head>   
      <script type = "text/javascript">
         <!--
         //-->
      </script>      
   </head>
   
   <body>   
      <p>다음을 클릭하세요. 전혀 반응하지 않을 것입니다...</p>
      <a href = "javascript:void(0)">Click me!</a>      
   </body>
</html>
```

### 출력

### 예제 3
`void`의 또 다른 사용은 의도적으로 `undefined` 값을 생성하는 것입니다.

```html
<html>
   <head>      
      <script type = "text/javascript">
         <!--
            function getValue() {
               var a,b,c;
               
               a = void ( b = 5, c = 7 );
               document.write('a = ' + a + ' b = ' + b +' c = ' + c );
            }
         //-->
      </script>      
   </head>
   
   <body>
      <p>결과를 보려면 다음을 클릭하세요:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "getValue();" />
      </form>     
   </body>
</html>
```

### 출력

---
## JavaScript - Page Printing

많은 경우 실제 프린터로 웹 페이지의 내용을 인쇄하기 위해 웹 페이지에 버튼을 배치하고 싶을 것입니다. JavaScript는 window 객체의 print 함수를 사용하여 이 기능을 구현하는 데 도움을 줍니다.

JavaScript print 함수인 `window.print()`는 실행 시 현재 웹 페이지를 인쇄합니다. 이 함수를 onclick 이벤트를 사용하여 직접 호출할 수 있습니다. 다음 예제를 참고하세요.

### 예제
다음 예제를 시도해 보십시오.

```html
<html>
   <head>      
      <script type = "text/javascript">
         <!--
         //-->
      </script>
   </head>
   
   <body>      
      <form>
         <input type = "button" value = "Print" onclick = "window.print()" />
      </form>   
   </body>
</html>
```

### 출력

이 방법은 인쇄 목적으로 사용될 수 있지만, 추천되는 방법은 아닙니다. 프린터 친화적인 페이지는 실제로 텍스트만 있고, 이미지나 그래픽, 광고가 없는 페이지입니다.

다음과 같은 방법으로 페이지를 프린터 친화적으로 만들 수 있습니다 −

1. 페이지의 복사본을 만들어 불필요한 텍스트와 그래픽을 제외한 후, 원본에서 해당 프린터 친화적인 페이지로 링크를 연결합니다. 예제를 확인하십시오.
2. 페이지의 추가 복사본을 유지하고 싶지 않다면, <!-- PRINT STARTS HERE -->..... <!-- PRINT ENDS HERE -->와 같은 적절한 주석을 사용하여 인쇄 가능한 텍스트를 표시한 다음, PERL 또는 다른 스크립트를 사용하여 인쇄 가능한 텍스트를 정리하고 최종 인쇄를 위해 표시할 수 있습니다. Tutorialspoint에서는 이 방법을 사용하여 사이트 방문자에게 인쇄 기능을 제공합니다.

### 페이지 인쇄 방법
위의 기능을 웹 페이지에서 찾을 수 없는 경우, 브라우저의 표준 도구 모음을 사용하여 웹 페이지를 인쇄할 수 있습니다. 다음과 같은 링크를 따르십시오.

File → Print → OK 버튼 클릭.

---
## JavaScript - Objects Overview

JavaScript는 객체 지향 프로그래밍(OOP) 언어입니다. 프로그래밍 언어가 객체 지향적이라고 불리려면 개발자에게 네 가지 기본 기능을 제공해야 합니다 −

- 캡슐화 − 데이터나 메서드 등 관련된 정보를 객체에 함께 저장할 수 있는 기능.
- 집합 − 한 객체 내에 다른 객체를 저장할 수 있는 기능.
- 상속 − 클래스가 다른 클래스(또는 여러 클래스)의 일부 속성과 메서드에 의존할 수 있는 기능.
- 다형성 − 하나의 함수나 메서드를 다양한 방식으로 사용할 수 있는 기능.

객체는 속성으로 구성됩니다. 속성에 함수가 포함되어 있으면 메서드라고 하고, 그렇지 않으면 속성이라고 합니다.

### 객체 속성
객체 속성은 세 가지 기본 데이터 유형 또는 다른 객체와 같은 추상 데이터 유형일 수 있습니다. 객체 속성은 보통 객체의 메서드에서 내부적으로 사용되는 변수이지만, 페이지 전체에서 사용되는 전역 변수일 수도 있습니다.

객체에 속성을 추가하는 구문은 다음과 같습니다 −

```javascript
objectName.objectProperty = propertyValue;
```

예를 들어, 다음 코드는 `document` 객체의 `title` 속성을 사용하여 문서 제목을 가져옵니다.

```javascript
var str = document.title;
```

### 객체 메서드
메서드는 객체가 무언가를 하거나 객체에 대해 무언가를 할 수 있게 하는 함수입니다. 함수와 메서드의 차이는 함수는 독립적인 문장 단위이고 메서드는 객체에 첨부되어 `this` 키워드로 참조될 수 있다는 점입니다.

메서드는 객체의 내용을 화면에 표시하거나, 로컬 속성과 매개변수에 대해 복잡한 수학 연산을 수행하는 데 유용합니다.

예를 들어, 다음은 `document` 객체의 `write()` 메서드를 사용하여 문서에 내용을 쓰는 간단한 예제입니다.

```javascript
document.write("This is test");
```

### 사용자 정의 객체
모든 사용자 정의 객체와 내장 객체는 `Object`라는 객체의 하위 객체입니다.

### new 연산자
`new` 연산자는 객체 인스턴스를 생성하는 데 사용됩니다. 객체를 생성하려면 `new` 연산자 뒤에 생성자 메서드를 붙입니다.

다음 예제에서 생성자 메서드는 `Object()`, `Array()`, `Date()`입니다. 이 생성자는 JavaScript의 내장 함수입니다.

```javascript
var employee = new Object();
var books = new Array("C++", "Perl", "Java");
var day = new Date("August 15, 1947");
```

### Object() 생성자
생성자는 객체를 생성하고 초기화하는 함수입니다. JavaScript는 객체를 만들기 위해 `Object()`라는 특수 생성자 함수를 제공합니다. `Object()` 생성자의 반환 값은 변수에 할당됩니다.

변수는 새 객체에 대한 참조를 포함합니다. 객체에 할당된 속성은 변수가 아니며 `var` 키워드로 정의되지 않습니다.

#### 예제 1
다음 예제를 시도해 보십시오. 객체를 생성하는 방법을 보여줍니다.

```html
<html>
   <head>
      <title>User-defined objects</title>     
      <script type = "text/javascript">
         var book = new Object();   // 객체 생성
         book.subject = "Perl";     // 객체에 속성 할당
         book.author  = "Mohtashim";
      </script>      
   </head>
   
   <body>  
      <script type = "text/javascript">
         document.write("Book name is : " + book.subject + "<br>");
         document.write("Book author is : " + book.author + "<br>");
      </script>   
   </body>
</html>
```

### 출력
Book name is : Perl 
Book author is : Mohtashim

#### 예제 2
이 예제는 사용자 정의 함수를 사용하여 객체를 생성하는 방법을 보여줍니다. 여기서 `this` 키워드는 함수에 전달된 객체를 참조하는 데 사용됩니다.

```html
<html>
   <head>   
      <title>User-defined objects</title>
      <script type = "text/javascript">
         function book(title, author) {
            this.title = title; 
            this.author  = author;
         }
      </script>      
   </head>
   
   <body>   
      <script type = "text/javascript">
         var myBook = new book("Perl", "Mohtashim");
         document.write("Book title is : " + myBook.title + "<br>");
         document.write("Book author is : " + myBook.author + "<br>");
      </script>      
   </body>
</html>
```

### 출력
Book title is : Perl 
Book author is : Mohtashim

### 객체에 메서드 정의하기
이전 예제는 생성자가 객체를 생성하고 속성을 할당하는 방법을 보여줍니다. 하지만 메서드를 할당하여 객체의 정의를 완성해야 합니다.

#### 예제
다음 예제를 시도해 보십시오. 객체와 함께 함수를 추가하는 방법을 보여줍니다.

```html
<html>
   <head>
      <title>User-defined objects</title>
      <script type = "text/javascript">
         // 메서드로 작동할 함수를 정의
         function addPrice(amount) {
            this.price = amount; 
         }
         
         function book(title, author) {
            this.title = title;
            this.author  = author;
            this.addPrice = addPrice;  // 메서드를 속성으로 할당
         }
      </script>      
   </head>
   
   <body>   
      <script type = "text/javascript">
         var myBook = new book("Perl", "Mohtashim");
         myBook.addPrice(100);
         
         document.write("Book title is : " + myBook.title + "<br>");
         document.write("Book author is : " + myBook.author + "<br>");
         document.write("Book price is : " + myBook.price + "<br>");
      </script>      
   </body>
</html>
```

### 출력
Book title is : Perl 
Book author is : Mohtashim 
Book price is : 100

### 'with' 키워드
`with` 키워드는 객체의 속성이나 메서드를 참조하는 데 사용되는 일종의 축약형입니다.

`with`의 인수로 지정된 객체는 다음 블록의 기본 객체가 됩니다. 객체의 속성과 메서드는 객체 이름을 명시하지 않고 사용할 수 있습니다.

### 구문
`with` 객체의 구문은 다음과 같습니다 −

```javascript
with (object) {
   properties used without the object name and dot
}
```

#### 예제
다음 예제를 시도해 보십시오.

```html
<html>
   <head>
      <title>User-defined objects</title>   
      <script type = "text/javascript">
         // 메서드로 작동할 함수를 정의
         function addPrice(amount) {
            with(this) {
               price = amount;
            }
         }
         function book(title, author) {
            this.title = title;
            this.author = author;
            this.price = 0;
            this.addPrice = addPrice;  // 메서드를 속성으로 할당
         }
      </script>      
   </head>
   
   <body>   
      <script type = "text/javascript">
         var myBook = new book("Perl", "Mohtashim");
         myBook.addPrice(100);
         
         document.write("Book title is : " + myBook.title + "<br>");
         document.write("Book author is : " + myBook.author + "<br>");
         document.write("Book price is : " + myBook.price + "<br>");
      </script>      
   </body>
</html>
```

### 출력
Book title is : Perl 
Book author is : Mohtashim 
Book price is : 100

### JavaScript 네이티브 객체
JavaScript에는 몇 가지 내장 또는 네이티브 객체가 있습니다. 이러한 객체는 프로그램 어디에서나 접근할 수 있으며, 어떤 운영 체제에서 실행되든지 동일한 방식으로 작동합니다.

다음은 모든 중요한 JavaScript 네이티브 객체의 목록입니다 −

- JavaScript Number 객체
- JavaScript Boolean 객체
- JavaScript String 객체
- JavaScript Array 객체
- JavaScript Date 객체
- JavaScript Math 객체
- JavaScript RegExp 객체

---
## JavaScript - The Number Object

Number 객체는 정수 또는 부동 소수점 숫자를 나타냅니다. 일반적으로, 브라우저는 숫자 리터럴을 숫자 클래스의 인스턴스로 자동으로 변환하기 때문에 Number 객체에 대해 걱정할 필요는 없습니다.

### 구문
숫자 객체를 생성하는 구문은 다음과 같습니다 −

```javascript
var val = new Number(number);
```

숫자 대신 숫자가 아닌 인수를 제공하면, 해당 인수는 숫자로 변환될 수 없기 때문에 NaN(Not-a-Number)을 반환합니다.

### Number 속성
다음은 각 속성과 그 설명의 목록입니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **MAX_VALUE**: JavaScript에서 숫자가 가질 수 있는 가장 큰 값 1.7976931348623157E+308 |
| 2 | **MIN_VALUE**: JavaScript에서 숫자가 가질 수 있는 가장 작은 값 5E-324 |
| 3 | **NaN**: 숫자가 아닌 값과 동일합니다. |
| 4 | **NEGATIVE_INFINITY**: MIN_VALUE보다 작은 값입니다. |
| 5 | **POSITIVE_INFINITY**: MAX_VALUE보다 큰 값입니다. |
| 6 | **prototype**: Number 객체의 정적 속성입니다. 현재 문서에서 Number 객체에 새 속성과 메서드를 할당하는 데 prototype 속성을 사용합니다. |
| 7 | **constructor**: 이 객체의 인스턴스를 생성한 함수를 반환합니다. 기본적으로 이것은 Number 객체입니다. |

다음 섹션에서는 Number 속성을 설명하기 위해 몇 가지 예제를 살펴보겠습니다.

### Number 메서드
Number 객체는 모든 객체 정의의 일부인 기본 메서드만 포함합니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **toExponential()**: 숫자가 JavaScript에서 일반적으로 사용하는 표준 표기 범위 내에 있더라도 지수 표기로 표시하도록 강제합니다. |
| 2 | **toFixed()**: 소수점 오른쪽에 특정 자릿수로 숫자를 형식화합니다. |
| 3 | **toLocaleString()**: 브라우저의 로컬 설정에 따라 형식이 다를 수 있는 현재 숫자의 문자열 값을 반환합니다. |
| 4 | **toPrecision()**: 숫자의 총 자릿수(소수점 왼쪽과 오른쪽 모두 포함)를 정의합니다. |
| 5 | **toString()**: 숫자의 값을 문자열로 반환합니다. |
| 6 | **valueOf()**: 숫자의 값을 반환합니다. |

다음 섹션에서는 Number 메서드를 설명하기 위해 몇 가지 예제를 살펴보겠습니다.

---
## JavaScript - The Boolean Object

Boolean 객체는 "true" 또는 "false" 두 값을 나타냅니다. 값 매개변수가 생략되거나 0, -0, null, false, NaN, undefined 또는 빈 문자열("")인 경우 객체의 초기 값은 false입니다.

### 구문
Boolean 객체를 생성하려면 다음 구문을 사용합니다.

```javascript
var val = new Boolean(value);
```

### Boolean 속성
Boolean 객체의 속성 목록은 다음과 같습니다 −

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **constructor**: 객체를 생성한 Boolean 함수를 참조로 반환합니다. |
| 2 | **prototype**: prototype 속성을 사용하여 객체에 속성과 메서드를 추가할 수 있습니다. |

다음 섹션에서는 Boolean 객체의 속성을 설명하는 몇 가지 예제를 살펴보겠습니다.

### Boolean 메서드
Boolean 객체의 메서드와 그 설명은 다음과 같습니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **toSource()**: Boolean 객체의 소스를 포함하는 문자열을 반환합니다. 이 문자열을 사용하여 동일한 객체를 만들 수 있습니다. |
| 2 | **toString()**: 객체의 값에 따라 "true" 또는 "false" 문자열을 반환합니다. |
| 3 | **valueOf()**: Boolean 객체의 원시 값을 반환합니다. |

다음 섹션에서는 Boolean 메서드의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

---
## JavaScript - The Strings Object

String 객체는 일련의 문자를 다룰 수 있게 해줍니다. JavaScript는 문자열 원시 데이터 유형을 여러 도우미 메서드와 함께 감싸서 제공합니다.

JavaScript는 문자열 원시값과 String 객체 간의 자동 변환을 수행하기 때문에 문자열 원시값에서도 String 객체의 모든 도우미 메서드를 호출할 수 있습니다.

### 구문
String 객체를 생성하는 구문은 다음과 같습니다 −

```javascript
var val = new String(string);
```

String 매개변수는 적절히 인코딩된 일련의 문자입니다.

### String 속성
String 객체의 속성과 설명은 다음과 같습니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **constructor**: 객체를 생성한 String 함수를 참조로 반환합니다. |
| 2 | **length**: 문자열의 길이를 반환합니다. |
| 3 | **prototype**: prototype 속성을 사용하여 객체에 속성과 메서드를 추가할 수 있습니다. |

다음 섹션에서는 String 속성의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

### String 메서드
String 객체에서 사용할 수 있는 메서드와 그 설명은 다음과 같습니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **charAt()**: 지정된 인덱스의 문자를 반환합니다. |
| 2 | **charCodeAt()**: 지정된 인덱스의 문자의 유니코드 값을 나타내는 숫자를 반환합니다. |
| 3 | **concat()**: 두 문자열의 텍스트를 결합하여 새로운 문자열을 반환합니다. |
| 4 | **indexOf()**: 호출한 String 객체 내에서 지정된 값의 첫 번째 발생 인덱스를 반환하거나, 찾지 못하면 -1을 반환합니다. |
| 5 | **lastIndexOf()**: 호출한 String 객체 내에서 지정된 값의 마지막 발생 인덱스를 반환하거나, 찾지 못하면 -1을 반환합니다. |
| 6 | **localeCompare()**: 정렬 순서에서 참조 문자열이 주어진 문자열보다 앞에 오는지 뒤에 오는지 또는 동일한지를 나타내는 숫자를 반환합니다. |
| 7 | **match()**: 문자열에서 정규 표현식을 사용하여 일치하는 항목을 찾습니다. |
| 8 | **replace()**: 문자열에서 정규 표현식과 일치하는 항목을 찾아 새로운 하위 문자열로 대체합니다. |
| 9 | **search()**: 문자열에서 정규 표현식과 일치하는 항목을 검색합니다. |
| 10 | **slice()**: 문자열의 일부분을 추출하여 새로운 문자열을 반환합니다. |
| 11 | **split()**: 문자열을 하위 문자열로 분리하여 문자열 배열을 만듭니다. |
| 12 | **substr()**: 지정된 위치에서 시작하여 지정된 수의 문자까지 문자열을 반환합니다. |
| 13 | **substring()**: 문자열에서 두 인덱스 사이의 문자를 반환합니다. |
| 14 | **toLocaleLowerCase()**: 현재 로케일을 고려하여 문자열 내의 문자를 소문자로 변환합니다. |
| 15 | **toLocaleUpperCase()**: 현재 로케일을 고려하여 문자열 내의 문자를 대문자로 변환합니다. |
| 16 | **toLowerCase()**: 호출한 문자열 값을 소문자로 변환하여 반환합니다. |
| 17 | **toString()**: 지정된 객체를 나타내는 문자열을 반환합니다. |
| 18 | **toUpperCase()**: 호출한 문자열 값을 대문자로 변환하여 반환합니다. |
| 19 | **valueOf()**: 지정된 객체의 원시 값을 반환합니다. |

### String HTML 래퍼
다음은 적절한 HTML 태그로 감싼 문자열의 복사본을 반환하는 메서드 목록입니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **anchor()**: 하이퍼텍스트 대상으로 사용되는 HTML 앵커를 만듭니다. |
| 2 | **big()**: `<big>` 태그로 큰 글꼴로 표시될 문자열을 만듭니다. |
| 3 | **blink()**: `<blink>` 태그로 깜빡이는 문자열을 만듭니다. |
| 4 | **bold()**: `<b>` 태그로 굵게 표시될 문자열을 만듭니다. |
| 5 | **fixed()**: `<tt>` 태그로 고정 폭 글꼴로 표시될 문자열을 만듭니다. |
| 6 | **fontcolor()**: `<font color="color">` 태그로 지정된 색상으로 표시될 문자열을 만듭니다. |
| 7 | **fontsize()**: `<font size="size">` 태그로 지정된 글꼴 크기로 표시될 문자열을 만듭니다. |
| 8 | **italics()**: `<i>` 태그로 기울임꼴로 표시될 문자열을 만듭니다. |
| 9 | **link()**: 다른 URL을 요청하는 HTML 하이퍼텍스트 링크를 만듭니다. |
| 10 | **small()**: `<small>` 태그로 작은 글꼴로 표시될 문자열을 만듭니다. |
| 11 | **strike()**: `<strike>` 태그로 취소선이 있는 텍스트로 표시될 문자열을 만듭니다. |
| 12 | **sub()**: `<sub>` 태그로 아래 첨자로 표시될 문자열을 만듭니다. |
| 13 | **sup()**: `<sup>` 태그로 위 첨자로 표시될 문자열을 만듭니다. |

다음 섹션에서는 String 메서드의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

---
## JavaScript - The Arrays Object

Array 객체를 사용하면 단일 변수에 여러 값을 저장할 수 있습니다. 동일한 유형의 요소로 구성된 고정 크기 순차 컬렉션을 저장합니다. 배열은 데이터 컬렉션을 저장하는 데 사용되지만, 배열을 동일한 유형의 변수 컬렉션으로 생각하는 것이 더 유용합니다.

### 구문
배열 객체를 생성하는 구문은 다음과 같습니다 −

```javascript
var fruits = new Array("apple", "orange", "mango");
```

Array 매개변수는 문자열 또는 정수 목록입니다. Array 생성자에 단일 숫자 매개변수를 지정하면 배열의 초기 길이를 지정하게 됩니다. 배열에 허용되는 최대 길이는 4,294,967,295입니다.

다음과 같이 값을 할당하여 배열을 생성할 수도 있습니다 −

```javascript
var fruits = ["apple", "orange", "mango"];
```

배열 내부의 값을 접근하고 설정하기 위해 서수 번호를 사용할 것입니다.

- `fruits[0]`은 첫 번째 요소입니다.
- `fruits[1]`은 두 번째 요소입니다.
- `fruits[2]`은 세 번째 요소입니다.

### 배열 속성
배열 객체의 속성과 설명 목록은 다음과 같습니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **constructor**: 객체를 생성한 배열 함수를 참조로 반환합니다. |
| 2 | **index**: 문자열에서 일치하는 요소의 0부터 시작하는 인덱스를 나타냅니다. |
| 3 | **input**: 정규 표현식 일치로 생성된 배열에만 존재하는 속성입니다. |
| 4 | **length**: 배열의 요소 수를 반영합니다. |
| 5 | **prototype**: prototype 속성을 사용하여 객체에 속성과 메서드를 추가할 수 있습니다. |

다음 섹션에서는 배열 속성의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

### 배열 메서드
배열 객체의 메서드와 그 설명은 다음과 같습니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **concat()**: 이 배열과 다른 배열(들) 및/또는 값(들)을 결합한 새로운 배열을 반환합니다. |
| 2 | **every()**: 이 배열의 모든 요소가 제공된 테스트 함수의 조건을 만족하면 true를 반환합니다. |
| 3 | **filter()**: 제공된 필터링 함수가 true를 반환하는 이 배열의 모든 요소로 구성된 새 배열을 만듭니다. |
| 4 | **forEach()**: 배열의 각 요소에 대해 함수를 호출합니다. |
| 5 | **indexOf()**: 배열 내에서 지정된 값과 동일한 요소의 첫 번째 인덱스를 반환하거나, 찾지 못하면 -1을 반환합니다. |
| 6 | **join()**: 배열의 모든 요소를 문자열로 결합합니다. |
| 7 | **lastIndexOf()**: 배열 내에서 지정된 값과 동일한 요소의 마지막 인덱스를 반환하거나, 찾지 못하면 -1을 반환합니다. |
| 8 | **map()**: 이 배열의 각 요소에 제공된 함수를 호출한 결과로 구성된 새 배열을 만듭니다. |
| 9 | **pop()**: 배열에서 마지막 요소를 제거하고 그 요소를 반환합니다. |
| 10 | **push()**: 배열의 끝에 하나 이상의 요소를 추가하고 배열의 새로운 길이를 반환합니다. |
| 11 | **reduce()**: 배열의 두 값에 동시에 함수를 적용하여 단일 값으로 축소합니다(왼쪽에서 오른쪽으로). |
| 12 | **reduceRight()**: 배열의 두 값에 동시에 함수를 적용하여 단일 값으로 축소합니다(오른쪽에서 왼쪽으로). |
| 13 | **reverse()**: 배열 요소의 순서를 반대로 바꿉니다(첫 번째 요소가 마지막 요소가 되고 마지막 요소가 첫 번째 요소가 됩니다). |
| 14 | **shift()**: 배열에서 첫 번째 요소를 제거하고 그 요소를 반환합니다. |
| 15 | **slice()**: 배열의 일부분을 추출하여 새로운 배열을 반환합니다. |
| 16 | **some()**: 이 배열의 적어도 하나의 요소가 제공된 테스트 함수의 조건을 만족하면 true를 반환합니다. |
| 17 | **toSource()**: 객체의 소스 코드를 나타냅니다. |
| 18 | **sort()**: 배열의 요소를 정렬합니다. |
| 19 | **splice()**: 배열에서 요소를 추가 및/또는 제거합니다. |
| 20 | **toString()**: 배열과 그 요소를 나타내는 문자열을 반환합니다. |
| 21 | **unshift()**: 배열의 앞에 하나 이상의 요소를 추가하고 배열의 새로운 길이를 반환합니다. |

다음 섹션에서는 배열 메서드의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

---
## JavaScript - The Date Object

Date 객체는 JavaScript 언어에 내장된 데이터 타입입니다. Date 객체는 아래와 같이 `new Date()`를 사용하여 생성됩니다.

Date 객체가 생성되면, 여러 메서드를 통해 조작할 수 있습니다. 대부분의 메서드는 단순히 연도, 월, 일, 시, 분, 초, 밀리초 필드를 로컬 시간 또는 UTC(세계 협정시, GMT) 시간으로 가져오거나 설정할 수 있습니다.

ECMAScript 표준은 Date 객체가 1/1/1970 전후 1억일 이내의 날짜와 시간을 밀리초 단위로 정확하게 표현할 수 있어야 한다고 요구합니다. 이는 ±273,785년의 범위로, JavaScript는 275755년까지 날짜와 시간을 표현할 수 있습니다.

### 구문
다음 구문 중 하나를 사용하여 Date 객체를 생성할 수 있습니다.

```javascript
new Date();
new Date(milliseconds);
new Date(datestring);
new Date(year, month, date[, hour, minute, second, millisecond ]);
```

참고 - 대괄호 안의 매개변수는 항상 선택 사항입니다.

여기 각 매개변수에 대한 설명이 있습니다 −

- **인수 없음**: 인수가 없는 경우, `Date()` 생성자는 현재 날짜와 시간으로 설정된 Date 객체를 생성합니다.
- **milliseconds**: 하나의 숫자 인수가 전달되면, 이는 `getTime()` 메서드가 반환하는 날짜의 내부 숫자 표현(밀리초)로 간주됩니다. 예를 들어, 인수로 5000을 전달하면 1/1/70 자정에서 5초가 지난 날짜를 나타냅니다.
- **datestring**: 하나의 문자열 인수가 전달되면, 이는 `Date.parse()` 메서드에서 허용하는 형식의 날짜 문자열 표현입니다.
- **7개의 인수**: 마지막 형태의 생성자를 사용하려면, 여기 각 인수에 대한 설명이 있습니다 −
  - **year**: 연도를 나타내는 정수 값입니다. 호환성을 위해(또는 Y2K 문제를 피하기 위해), 항상 연도를 전체로 지정해야 합니다; 예를 들어, 98 대신 1998을 사용하세요.
  - **month**: 월을 나타내는 정수 값으로, 0은 1월을, 11은 12월을 나타냅니다.
  - **date**: 월의 일자를 나타내는 정수 값입니다.
  - **hour**: 하루의 시간을 나타내는 정수 값(24시간제)입니다.
  - **minute**: 시간의 분 부분을 나타내는 정수 값입니다.
  - **second**: 시간의 초 부분을 나타내는 정수 값입니다.
  - **millisecond**: 시간의 밀리초 부분을 나타내는 정수 값입니다.

### Date 속성
Date 객체의 속성과 그 설명 목록은 다음과 같습니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **constructor**: 객체의 프로토타입을 생성하는 함수를 지정합니다. |
| 2 | **prototype**: 프로토타입 속성을 사용하여 객체에 속성과 메서드를 추가할 수 있습니다. |

다음 섹션에서는 다양한 Date 속성의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

### Date 메서드
Date와 함께 사용되는 메서드와 그 설명은 다음과 같습니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **Date()**: 오늘의 날짜와 시간을 반환합니다. |
| 2 | **getDate()**: 지정된 날짜의 일자를 로컬 시간에 따라 반환합니다. |
| 3 | **getDay()**: 지정된 날짜의 요일을 로컬 시간에 따라 반환합니다. |
| 4 | **getFullYear()**: 지정된 날짜의 연도를 로컬 시간에 따라 반환합니다. |
| 5 | **getHours()**: 지정된 날짜의 시간을 로컬 시간에 따라 반환합니다. |
| 6 | **getMilliseconds()**: 지정된 날짜의 밀리초를 로컬 시간에 따라 반환합니다. |
| 7 | **getMinutes()**: 지정된 날짜의 분을 로컬 시간에 따라 반환합니다. |
| 8 | **getMonth()**: 지정된 날짜의 월을 로컬 시간에 따라 반환합니다. |
| 9 | **getSeconds()**: 지정된 날짜의 초를 로컬 시간에 따라 반환합니다. |
| 10 | **getTime()**: 1970년 1월 1일 00:00:00 UTC 이후 밀리초로 지정된 날짜의 숫자 값을 반환합니다. |
| 11 | **getTimezoneOffset()**: 현재 로케일의 시간대 오프셋을 분 단위로 반환합니다. |
| 12 | **getUTCDate()**: 지정된 날짜의 월 일자를 UTC 시간에 따라 반환합니다. |
| 13 | **getUTCDay()**: 지정된 날짜의 요일을 UTC 시간에 따라 반환합니다. |
| 14 | **getUTCFullYear()**: 지정된 날짜의 연도를 UTC 시간에 따라 반환합니다. |
| 15 | **getUTCHours()**: 지정된 날짜의 시간을 UTC 시간에 따라 반환합니다. |
| 16 | **getUTCMilliseconds()**: 지정된 날짜의 밀리초를 UTC 시간에 따라 반환합니다. |
| 17 | **getUTCMinutes()**: 지정된 날짜의 분을 UTC 시간에 따라 반환합니다. |
| 18 | **getUTCMonth()**: 지정된 날짜의 월을 UTC 시간에 따라 반환합니다. |
| 19 | **getUTCSeconds()**: 지정된 날짜의 초를 UTC 시간에 따라 반환합니다. |
| 20 | **getYear()**: 사용되지 않음 - 지정된 날짜의 연도를 로컬 시간에 따라 반환합니다. 대신 `getFullYear`를 사용하세요. |
| 21 | **setDate()**: 로컬 시간에 따라 지정된 날짜의 일자를 설정합니다. |
| 22 | **setFullYear()**: 로컬 시간에 따라 지정된 날짜의 전체 연도를 설정합니다. |
| 23 | **setHours()**: 로컬 시간에 따라 지정된 날짜의 시간을 설정합니다. |
| 24 | **setMilliseconds()**: 로컬 시간에 따라 지정된 날짜의 밀리초를 설정합니다. |
| 25 | **setMinutes()**: 로컬 시간에 따라 지정된 날짜의 분을 설정합니다. |
| 26 | **setMonth()**: 로컬 시간에 따라 지정된 날짜의 월을 설정합니다. |
| 27 | **setSeconds()**: 로컬 시간에 따라 지정된 날짜의 초를 설정합니다. |
| 28 | **setTime()**: Date 객체를 1970년 1월 1일 00:00:00 UTC 이후 밀리초로 표현된 시간으로 설정합니다. |
| 29 | **setUTCDate()**: UTC 시간에 따라 지정된 날짜의 일자를 설정합니다. |
| 30 | **setUTCFullYear()**: UTC 시간에 따라 지정된 날짜의 전체 연도를 설정합니다. |
| 31 | **setUTCHours()**: UTC 시간에 따라 지정된 날짜의 시간을 설정합니다. |
| 32 | **setUTCMilliseconds()**: UTC 시간에 따라 지정된 날짜의 밀리초를 설정합니다. |
| 33 | **setUTCMinutes()**: UTC 시간에 따라 지정된 날짜의 분을 설정합니다. |
| 34 | **setUTCMonth()**: UTC 시간에 따라 지정된 날짜의 월을 설정합니다. |
| 35 | **setUTCSeconds()**: UTC 시간에 따라 지정된 날짜의 초를 설정합니다. |
| 36 | **setYear()**: 사용되지 않음 - 지정된 날짜의 연도를 로컬 시간에 따라 설정합니다. 대신 `setFullYear`를 사용하세요. |
| 37 | **toDateString()**: Date의 "날짜" 부분을 사람이 읽을 수 있는 문자열로 반환합니다. |
| 38 | **toGMTString()**: 사용되지 않음 - 날짜를 문자열로 변환합니다. 인터넷 GMT 규칙을 사용합니다. 대신 `toUTCString`을 사용하세요. |
| 39 | **toLocaleDateString()**: 현재 로케일의 규칙을 사용하여 Date의 "날짜" 부분을 문자열로 반환합니다. |
| 40 | **toLocaleFormat()**: 날짜를 포맷 문자열을 사용하여 문자열로 변환합니다. |
| 41 | **toLocaleString()**: 현재 로케일의 규칙을 사용하여 날짜를 문자열로 변환합니다. |
| 42 | **toLocaleTimeString()**: 현재 로케일의 규칙을 사용하여 Date의 "시간" 부분을 문자열로 반환합니다. |
| 43 | **toSource()**: 동등한 Date 객체의 소스를 나타내는 문자열을 반환합니다. 이 값을 사용하여 새 객체를 만들 수 있습니다. |
| 44 | **toString()**: 지정된 Date 객체를 나타내는 문자열을 반환합니다. |
| 45 | **toTimeString()**: Date의 "시간" 부분을 사람이 읽을 수 있는 문자열로 반환합니다

. |
| 46 | **toUTCString()**: 날짜를 문자열로 변환합니다. UTC 규칙을 사용합니다. |
| 47 | **valueOf()**: Date 객체의 기본 값을 반환합니다. |

### Date 정적 메서드
이전에 나열된 많은 인스턴스 메서드 외에도 Date 객체는 두 가지 정적 메서드를 정의합니다. 이 메서드는 Date() 생성자를 통해 호출됩니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **Date.parse()**: 날짜와 시간의 문자열 표현을 분석하고 그 날짜의 내부 밀리초 표현을 반환합니다. |
| 2 | **Date.UTC()**: 지정된 UTC 날짜와 시간의 밀리초 표현을 반환합니다. |

다음 섹션에서는 Date 정적 메서드의 사용법을 설명하는 몇 가지 예제를 살펴보겠습니다.

---
## JavaScript - The Math Object

Math 객체는 수학 상수 및 함수를 위한 속성과 메서드를 제공합니다. 다른 글로벌 객체와 달리, Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적이며, Math 객체를 생성하지 않고도 Math를 객체로 사용하여 호출할 수 있습니다.

따라서, 상수 파이를 Math.PI로 참조하고 사인 함수를 Math.sin(x)로 호출합니다. 여기서 x는 메서드의 인수입니다.

### 구문
Math의 속성과 메서드를 호출하는 구문은 다음과 같습니다.

```javascript
var pi_val = Math.PI;
var sine_val = Math.sin(30);
```

### Math 속성
Math의 모든 속성과 그 설명 목록은 다음과 같습니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **E**: 오일러 상수이자 자연 로그의 밑, 약 2.718. |
| 2 | **LN2**: 2의 자연 로그, 약 0.693. |
| 3 | **LN10**: 10의 자연 로그, 약 2.302. |
| 4 | **LOG2E**: E의 밑수가 2인 로그, 약 1.442. |
| 5 | **LOG10E**: E의 밑수가 10인 로그, 약 0.434. |
| 6 | **PI**: 원주율(파이), 약 3.14159. |
| 7 | **SQRT1_2**: 1/2의 제곱근; 동등하게, 2의 제곱근의 역수, 약 0.707. |
| 8 | **SQRT2**: 2의 제곱근, 약 1.414. |

다음 섹션에서는 Math 속성의 사용 예제를 살펴보겠습니다.

### Math 메서드
Math 객체와 관련된 메서드와 그 설명 목록은 다음과 같습니다.

| 번호 | 메서드 및 설명 |
| --- | --------------- |
| 1 | **abs()**: 숫자의 절대값을 반환합니다. |
| 2 | **acos()**: 숫자의 아크 코사인(라디안)을 반환합니다. |
| 3 | **asin()**: 숫자의 아크 사인(라디안)을 반환합니다. |
| 4 | **atan()**: 숫자의 아크 탄젠트(라디안)를 반환합니다. |
| 5 | **atan2()**: 인수의 몫의 아크 탄젠트를 반환합니다. |
| 6 | **ceil()**: 주어진 숫자보다 크거나 같은 가장 작은 정수를 반환합니다. |
| 7 | **cos()**: 숫자의 코사인을 반환합니다. |
| 8 | **exp()**: E의 N승을 반환합니다. 여기서 N은 인수이고, E는 오일러 상수이자 자연 로그의 밑입니다. |
| 9 | **floor()**: 주어진 숫자보다 작거나 같은 가장 큰 정수를 반환합니다. |
| 10 | **log()**: 숫자의 자연 로그(밑 E)를 반환합니다. |
| 11 | **max()**: 0개 이상의 숫자 중 가장 큰 숫자를 반환합니다. |
| 12 | **min()**: 0개 이상의 숫자 중 가장 작은 숫자를 반환합니다. |
| 13 | **pow()**: 밑수를 지수만큼 제곱한 값을 반환합니다. |
| 14 | **random()**: 0과 1 사이의 의사 난수를 반환합니다. |
| 15 | **round()**: 주어진 숫자를 가장 가까운 정수로 반올림한 값을 반환합니다. |
| 16 | **sin()**: 숫자의 사인을 반환합니다. |
| 17 | **sqrt()**: 숫자의 제곱근을 반환합니다. |
| 18 | **tan()**: 숫자의 탄젠트를 반환합니다. |
| 19 | **toSource()**: 문자열 "Math"를 반환합니다. |

다음 섹션에서는 Math와 관련된 메서드의 사용 예제를 살펴보겠습니다.

---
## Regular Expressions and RegExp Object

정규 표현식은 문자 패턴을 설명하는 객체입니다.

자바스크립트의 RegExp 클래스는 정규 표현식을 나타내며, String과 RegExp는 정규 표현식을 사용하여 강력한 패턴 매칭 및 검색-대체 기능을 수행하는 메서드를 정의합니다.

### 구문
정규 표현식은 RegExp() 생성자를 사용하여 정의할 수 있습니다. 예를 들면 다음과 같습니다.

```javascript
var pattern = new RegExp(pattern, attributes);
```
또는 간단하게
```javascript
var pattern = /pattern/attributes;
```
다음은 매개변수에 대한 설명입니다.

- `pattern` − 정규 표현식의 패턴을 지정하는 문자열 또는 다른 정규 표현식.
- `attributes` − 선택적 문자열로, 전역 매치(g), 대소문자 구분 없음(i), 다중 라인 매치(m)을 각각 지정하는 "g", "i", "m" 속성을 포함할 수 있습니다.

### 대괄호
대괄호([])는 정규 표현식의 문맥에서 특별한 의미를 가집니다. 문자의 범위를 찾는 데 사용됩니다.

| 번호 | 표현식 및 설명 |
| --- | ------------- |
| 1 | `[...]` 대괄호 안의 임의의 문자 |
| 2 | `[^...]` 대괄호 안에 없는 임의의 문자 |
| 3 | `[0-9]` 0부터 9까지의 십진수와 일치 |
| 4 | `[a-z]` 소문자 a부터 소문자 z까지의 문자와 일치 |
| 5 | `[A-Z]` 대문자 A부터 대문자 Z까지의 문자와 일치 |
| 6 | `[a-Z]` 소문자 a부터 대문자 Z까지의 문자와 일치 |

위의 범위는 일반적입니다. 예를 들어, [0-3] 범위를 사용하여 0에서 3까지의 십진수와 일치하거나, [b-v] 범위를 사용하여 소문자 b에서 소문자 v까지의 문자와 일치시킬 수 있습니다.

### 수량자
대괄호로 묶인 문자 시퀀스 및 단일 문자의 빈도 또는 위치는 특수 문자로 표시할 수 있습니다. 각 특수 문자는 특정한 의미를 가집니다. +, *, ?, $ 플래그는 모두 문자 시퀀스를 따릅니다.

| 번호 | 표현식 및 설명 |
| --- | ------------- |
| 1 | `p+` 하나 이상의 p를 포함하는 모든 문자열과 일치 |
| 2 | `p*` 0개 이상의 p를 포함하는 모든 문자열과 일치 |
| 3 | `p?` 최대 하나의 p를 포함하는 모든 문자열과 일치 |
| 4 | `p{N}` N개의 p 시퀀스를 포함하는 모든 문자열과 일치 |
| 5 | `p{2,3}` 두 개 또는 세 개의 p 시퀀스를 포함하는 모든 문자열과 일치 |
| 6 | `p{2, }` 최소 두 개의 p 시퀀스를 포함하는 모든 문자열과 일치 |
| 7 | `p$` 끝에 p가 있는 모든 문자열과 일치 |
| 8 | `^p` 시작에 p가 있는 모든 문자열과 일치 |

### 예제
다음 예제는 문자 매칭에 대해 더 설명합니다.

| 번호 | 표현식 및 설명 |
| --- | ------------- |
| 1 | `[^a-zA-Z]` a부터 z까지와 A부터 Z까지의 문자를 포함하지 않는 모든 문자열과 일치 |
| 2 | `p.p` p 뒤에 임의의 문자가 오고 다시 p가 오는 모든 문자열과 일치 |
| 3 | `^.{2}$` 정확히 두 문자를 포함하는 모든 문자열과 일치 |
| 4 | `<b>(.*)</b>` <b>와 </b>로 둘러싸인 모든 문자열과 일치 |
| 5 | `p(hp)*` p 뒤에 0개 이상의 hp 시퀀스가 오는 모든 문자열과 일치 |

### 리터럴 문자
| 번호 | 문자 및 설명 |
| --- | ------------- |
| 1 | **Alphanumeric** 자체 |
| 2 | `\0` NUL 문자 (\u0000) |
| 3 | `\t` 탭 (\u0009) |
| 4 | `\n` 줄 바꿈 (\u000A) |
| 5 | `\v` 수직 탭 (\u000B) |
| 6 | `\f` 폼 피드 (\u000C) |
| 7 | `\r` 캐리지 리턴 (\u000D) |
| 8 | `\xnn` 16진수 nn으로 지정된 라틴 문자. 예: \x0A는 \n과 동일 |
| 9 | `\uxxxx` 16진수 xxxx로 지정된 유니코드 문자. 예: \u0009는 \t와 동일 |
| 10 | `\cX` 제어 문자 ^X. 예: \cJ는 줄 바꿈 문자 \n과 동일 |

### 메타 문자
메타 문자는 특수한 의미를 갖기 위해 백슬래시가 앞에 붙는 알파벳 문자입니다.

예를 들어, '\d' 메타 문자를 사용하여 큰 금액을 검색할 수 있습니다: /([\d]+)000/. 여기서 \d는 숫자 문자열을 검색합니다.

다음 표는 PERL 스타일 정규 표현식에서 사용할 수 있는 메타 문자 세트를 나열합니다.

| 번호 | 문자 및 설명 |
| --- | ------------- |
| 1 | **.** 단일 문자 |
| 2 | **\s** 공백 문자 (공백, 탭, 줄 바꿈) |
| 3 | **\S** 비공백 문자 |
| 4 | **\d** 숫자 (0-9) |
| 5 | **\D** 비숫자 |
| 6 | **\w** 단어 문자 (a-z, A-Z, 0-9, _) |
| 7 | **\W** 비단어 문자 |
| 8 | **[\b]** 리터럴 백스페이스 (특수한 경우) |
| 9 | **[aeiou]** 주어진 집합의 단일 문자와 일치 |
| 10 | **[^aeiou]** 주어진 집합 외부의 단일 문자와 일치 |
| 11 | **`(foo|bar|baz)`** 지정된 대안 중 하나와 일치 |

### 수식어
여러 수식어를 사용하여 정규 표현식을 더 쉽게 작업할 수 있습니다. 예를 들어, 대소문자 구분, 다중 라인 검색 등.

| 번호 | 수식어 및 설명 |
| --- | ------------- |
| 1 | **i** 대소문자 구분 없이 매칭 수행 |
| 2 | **m** 문자열에 줄 바꿈 또는 캐리지 리턴 문자가 있는 경우, ^ 및 $ 연산자가 문자열 경계 대신 줄 바꿈 경계를 기준으로 매칭 |
| 3 | **g** 전역 매칭 수행, 즉 첫 번째 매칭 후 멈추지 않고 모든 매칭을 찾음 |

### RegExp 속성
다음은 RegExp와 관련된 속성 목록과 그 설명입니다.

| 번호 | 속성 및 설명 |
| --- | ------------- |
| 1 | **constructor** 객체의 프로토타입을 생성하는 함수를 지정합니다. |
| 2 | **global** "g" 수식어가 설정되었는지 지정합니다. |
| 3 | **ignoreCase** "i" 수식어가 설정되었는지 지정합니다. |
| 4 | **lastIndex** 다음 매치를 시작할 인덱스입니다. |
| 5 | **multiline** "m" 수식어가 설정되었는지 지정합니다. |
| 6 | **source** 패턴의 텍스트입니다. |

다음 섹션에서는 RegExp 속성의 사용 예제를 살펴보겠습니다.

### RegExp 메서드
다음은 RegExp와 관련된 메서드 목록과 그 설명입니다.

| 번호 | 메서드 및 설명 |
| --- | ------------- |
| 1 | **exec()** 문자열 매치에 대해 검색을 실행합니다. |
| 2 | **test()** 문자열 매치에 대해 테스트합니다. |
| 3 | **toSource()** 지정된 객체를 나타내는 객체 리터럴을 반환합니다. 이 값을 사용하여 새 객체를 만들 수 있습니다. |
| 4 | **toString()** 지정된 객체를 나타내는 문자열을 반환합니다. |



다음 섹션에서는 RegExp 메서드의 사용 예제를 살펴보겠습니다.

---
## JavaScript - Document Object Model or DOM

모든 웹 페이지는 객체로 간주될 수 있는 브라우저 창 내부에 위치합니다.

문서 객체는 해당 창에 표시되는 HTML 문서를 나타냅니다. 문서 객체에는 문서 콘텐츠에 접근하고 수정할 수 있도록 하는 다양한 속성이 있습니다.

문서 콘텐츠에 접근하고 수정하는 방법을 문서 객체 모델(Document Object Model, DOM)이라고 합니다. 객체는 계층 구조로 구성됩니다. 이 계층 구조는 웹 문서의 객체 조직에 적용됩니다.

- 윈도우 객체(Window object) − 계층 구조의 최상위에 있습니다. 객체 계층 구조의 가장 바깥 요소입니다.
- 문서 객체(Document object) − 각 HTML 문서가 창에 로드될 때 문서 객체가 됩니다. 문서 객체는 페이지의 내용을 포함합니다.
- 폼 객체(Form object) − `<form>...</form>` 태그로 감싸진 모든 것이 폼 객체를 설정합니다.
- 폼 컨트롤 요소(Form control elements) − 폼 객체는 텍스트 필드, 버튼, 라디오 버튼 및 체크박스와 같은 해당 객체에 대해 정의된 모든 요소를 포함합니다.

다음은 몇 가지 중요한 객체의 간단한 계층 구조입니다.

### HTML DOM

여러 DOM이 존재합니다. 다음 섹션에서는 각각의 DOM에 대해 자세히 설명하고, 이를 사용하여 문서 콘텐츠에 접근하고 수정하는 방법을 설명합니다.

- **레거시 DOM(The Legacy DOM)** − 초기 자바스크립트 언어 버전에서 도입된 모델입니다. 모든 브라우저에서 잘 지원되지만, 양식, 양식 요소 및 이미지와 같은 문서의 특정 주요 부분에만 접근할 수 있습니다.
- **W3C DOM(The W3C DOM)** − 이 문서 객체 모델은 모든 문서 콘텐츠에 접근하고 수정할 수 있도록 하며, 월드 와이드 웹 컨소시엄(W3C)에서 표준화되었습니다. 이 모델은 거의 모든 최신 브라우저에서 지원됩니다.
- **IE4 DOM(The IE4 DOM)** − 이 문서 객체 모델은 마이크로소프트의 인터넷 익스플로러 버전 4에서 도입되었습니다. IE 5 및 이후 버전에서는 대부분의 기본 W3C DOM 기능을 지원합니다.

### DOM 호환성

W3C DOM 또는 IE 4 DOM을 사용하여 유연하게 스크립트를 작성하려면, 먼저 메서드 또는 속성의 존재 여부를 확인하여 브라우저가 원하는 기능을 가지고 있는지 확인하는 기능 테스트 접근 방식을 사용할 수 있습니다. 예를 들어,

```javascript
if (document.getElementById) {
   // W3C 메서드가 존재하면 이를 사용합니다.
} else if (document.all) {
   // all[] 배열이 존재하면 이를 사용합니다.
} else {
   // 그렇지 않으면 레거시 DOM을 사용합니다.
}
```

---
## JavaScript - Errors & Exceptions Handling


프로그래밍에는 세 가지 유형의 오류가 있습니다: (a) 문법 오류, (b) 런타임 오류, (c) 논리 오류.

### 문법 오류
문법 오류는 구문 분석 오류라고도 하며, 전통적인 프로그래밍 언어에서는 컴파일 시간에, 자바스크립트에서는 해석 시간에 발생합니다.

예를 들어, 다음 줄은 닫는 괄호가 없어 문법 오류를 일으킵니다.

```html
<script type = "text/javascript">
   window.print(;
</script>
```

자바스크립트에서 문법 오류가 발생하면, 동일한 스레드 내에 있는 코드만 영향을 받고, 다른 스레드의 코드는 오류가 포함된 코드에 의존하지 않는 한 계속 실행됩니다.

### 런타임 오류
런타임 오류는 예외라고도 하며, 실행 중에 발생합니다(컴파일/해석 후).

예를 들어, 다음 줄은 문법은 맞지만 실행 중에 존재하지 않는 메서드를 호출하려 하여 런타임 오류를 일으킵니다.

```html
<script type = "text/javascript">
   window.printme();
</script>
```

예외는 발생한 스레드에만 영향을 미치며, 다른 자바스크립트 스레드는 정상적으로 실행을 계속합니다.

### 논리 오류
논리 오류는 추적하기 가장 어려운 유형의 오류일 수 있습니다. 이러한 오류는 문법 오류나 런타임 오류의 결과가 아니며, 대신 스크립트를 구동하는 논리에서 실수를 할 때 발생하며 예상한 결과를 얻지 못합니다.

이러한 오류는 비즈니스 요구 사항에 따라 프로그램에 어떤 논리를 넣을지에 따라 다르기 때문에 잡을 수 없습니다.

### try...catch...finally 문
최신 버전의 자바스크립트는 예외 처리 기능을 추가했습니다. 자바스크립트는 예외를 처리하기 위해 try...catch...finally 구조와 throw 연산자를 구현합니다.

프로그래머가 생성한 예외와 런타임 예외를 잡을 수 있지만, 자바스크립트 문법 오류는 잡을 수 없습니다.

여기 try...catch...finally 블록의 구문이 있습니다:

```html
<script type = "text/javascript">
   try {
      // 실행할 코드
      [break;]
   } 
   catch ( e ) {
      // 예외가 발생할 경우 실행할 코드
      [break;]
   }
   [ finally {
      // 예외 발생 여부와 상관없이 항상 실행되는 코드
   }]
</script>
```

try 블록 다음에는 반드시 하나의 catch 블록 또는 하나의 finally 블록(또는 둘 다)이 와야 합니다. try 블록에서 예외가 발생하면 예외가 e에 할당되고 catch 블록이 실행됩니다. 선택적인 finally 블록은 try/catch 후 무조건 실행됩니다.

### 예제
다음은 존재하지 않는 함수를 호출하려고 해서 예외를 발생시키는 예제입니다. try...catch 없이 어떻게 동작하는지 보겠습니다.

```html
<html>
   <head>      
      <script type = "text/javascript">
         function myFunc() {
            var a = 100;
            alert("Value of variable a is : " + a );
         }
      </script>      
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>      
   </body>
</html>
```

이제 try...catch를 사용하여 이 예외를 잡고 사용자에게 친숙한 메시지를 표시해 보겠습니다. 원한다면 이 메시지를 숨길 수도 있습니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         function myFunc() {
            var a = 100;
            try {
               alert("Value of variable a is : " + a );
            } 
            catch ( e ) {
               alert("Error: " + e.description );
            }
         }
      </script>
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>
   </body>
</html>
```

finally 블록을 사용하여 try/catch 후 무조건 실행되는 코드를 작성할 수도 있습니다. 예제를 보겠습니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         function myFunc() {
            var a = 100;
            try {
               alert("Value of variable a is : " + a );
            }
            catch ( e ) {
               alert("Error: " + e.description );
            }
            finally {
               alert("Finally block will always execute!" );
            }
         }
      </script>
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>
   </body>
</html>
```

### throw 문
throw 문을 사용하여 내장 예외나 사용자 정의 예외를 발생시킬 수 있습니다. 나중에 이러한 예외를 잡아 적절한 조치를 취할 수 있습니다.

다음 예제는 throw 문을 사용하는 방법을 보여줍니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         function myFunc() {
            var a = 100;
            var b = 0;
            try {
               if ( b == 0 ) {
                  throw( "Divide by zero error." ); 
               } else {
                  var c = a / b;
               }
            }
            catch ( e ) {
               alert("Error: " + e );
            }
         }
      </script>
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>
   </body>
</html>
```

한 함수에서 문자열, 정수, 불리언 또는 객체를 사용하여 예외를 발생시키고 나중에 위의 방법처럼 동일한 함수에서 또는 다른 함수에서 try...catch 블록을 사용하여 해당 예외를 잡을 수 있습니다.

### onerror() 메서드
onerror 이벤트 핸들러는 자바스크립트에서 오류 처리를 용이하게 하기 위한 최초의 기능입니다. 페이지에서 예외가 발생할 때마다 window 객체에서 오류 이벤트가 발생합니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         window.onerror = function () {
            alert("An error occurred.");
         }
      </script>
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>
   </body>
</html>
```

onerror 이벤트 핸들러는 오류의 정확한 성격을 식별하기 위해 세 가지 정보를 제공합니다 −

- 오류 메시지 − 주어진 오류에 대해 브라우저가 표시하는 동일한 메시지
- URL − 오류가 발생한 파일
- 라인 번호 − 오류를 일으킨 주어진 URL의 라인 번호

다음 예제는 이 정보를 추출하는 방법을 보여줍니다.

```html
<html>
   <head>
      <script type = "text/javascript">
         window.onerror = function (msg, url, line) {
            alert("Message : " + msg );
            alert("url : " + url );
            alert("Line number : " + line );
         }
      </script>
   </head>
   <body>
      <p>Click the following to see the result:</p>
      <form>
         <input type = "button" value = "Click Me" onclick = "myFunc();" />
      </form>
   </body>
</html>
```

이미지 로드에 문제가 있는 경우 오류 메시지를 표시하는 onerror 메서드를 사용할 수도 있습니다.

```html
<img src="myimage.gif" onerror="alert('An error occurred loading the image.')" />
```

onerror를 사용하여 오류 발생 시 적절한 메시지를 표시할 수 있는 많은 HTML 태그와 함께 사용할 수 있습니다.

---
## JavaScript - Form Validation

폼 검증은 보통 서버에서 발생하며, 클라이언트가 모든 필요한 데이터를 입력하고 제출 버튼을 누른 후에 이루어집니다. 만약 클라이언트가 입력한 데이터가 잘못되었거나 누락된 경우, 서버는 모든 데이터를 클라이언트에게 다시 보내고 올바른 정보로 폼을 다시 제출하도록 요청해야 했습니다. 이는 서버에 많은 부담을 주는 매우 긴 프로세스였습니다.

자바스크립트는 웹 서버에 데이터를 보내기 전에 클라이언트 컴퓨터에서 폼의 데이터를 검증하는 방법을 제공합니다. 폼 검증은 일반적으로 두 가지 기능을 수행합니다.

### 기본 검증
먼저, 모든 필수 필드가 채워졌는지 확인해야 합니다. 이를 위해 폼의 각 필드를 순회하면서 데이터를 확인하면 됩니다.

### 데이터 형식 검증
두 번째로, 입력된 데이터가 올바른 형식과 값인지 확인해야 합니다. 코드에는 데이터의 올바름을 테스트할 적절한 로직이 포함되어야 합니다.

### 예제
다음 예제를 통해 검증 과정을 이해해 보겠습니다. 아래는 HTML 형식의 간단한 폼입니다.

```html
<html>   
   <head>
      <title>Form Validation</title>      
      <script type = "text/javascript">
         <!--
            // Form validation code will come here.
         //-->
      </script>      
   </head>
   
   <body>
      <form action = "/cgi-bin/test.cgi" name = "myForm" onsubmit = "return(validate());">
         <table cellspacing = "2" cellpadding = "2" border = "1">
            <tr>
               <td align = "right">Name</td>
               <td><input type = "text" name = "Name" /></td>
            </tr>
            <tr>
               <td align = "right">EMail</td>
               <td><input type = "text" name = "EMail" /></td>
            </tr>
            <tr>
               <td align = "right">Zip Code</td>
               <td><input type = "text" name = "Zip" /></td>
            </tr>
            <tr>
               <td align = "right">Country</td>
               <td>
                  <select name = "Country">
                     <option value = "-1" selected>[choose yours]</option>
                     <option value = "1">USA</option>
                     <option value = "2">UK</option>
                     <option value = "3">INDIA</option>
                  </select>
               </td>
            </tr>
            <tr>
               <td align = "right"></td>
               <td><input type = "submit" value = "Submit" /></td>
            </tr>
         </table>
      </form>      
   </body>
</html>
```

### 기본 폼 검증
먼저 기본적인 폼 검증을 하는 방법을 보겠습니다. 위의 폼에서, onsubmit 이벤트가 발생할 때 데이터를 검증하기 위해 `validate()`를 호출하고 있습니다. 다음 코드는 `validate()` 함수의 구현을 보여줍니다.

```html
<script type = "text/javascript">
   <!--
      function validate() {
         if( document.myForm.Name.value == "" ) {
            alert( "Please provide your name!" );
            document.myForm.Name.focus() ;
            return false;
         }
         if( document.myForm.EMail.value == "" ) {
            alert( "Please provide your Email!" );
            document.myForm.EMail.focus() ;
            return false;
         }
         if( document.myForm.Zip.value == "" || isNaN( document.myForm.Zip.value ) ||
            document.myForm.Zip.value.length != 5 ) {
            alert( "Please provide a zip in the format #####." );
            document.myForm.Zip.focus() ;
            return false;
         }
         if( document.myForm.Country.value == "-1" ) {
            alert( "Please provide your country!" );
            return false;
         }
         return( true );
      }
   //-->
</script>
```

### 데이터 형식 검증
이제 폼 데이터를 웹 서버에 제출하기 전에 입력된 데이터의 형식을 어떻게 검증할 수 있는지 보겠습니다.

다음 예제는 입력된 이메일 주소를 검증하는 방법을 보여줍니다. 이메일 주소에는 최소한 하나의 '@' 기호와 점('.')이 포함되어야 합니다. 또한, '@' 기호는 이메일 주소의 첫 번째 문자일 수 없으며, 마지막 점은 '@' 기호 뒤에 최소한 하나의 문자여야 합니다.

```html
<script type = "text/javascript">
   <!--
      function validateEmail() {
         var emailID = document.myForm.EMail.value;
         atpos = emailID.indexOf("@");
         dotpos = emailID.lastIndexOf(".");
         
         if (atpos < 1 || ( dotpos - atpos < 2 )) {
            alert("Please enter correct email ID")
            document.myForm.EMail.focus() ;
            return false;
         }
         return( true );
      }
   //-->
</script>
```
---
## JavaScript - Animation

자바스크립트를 사용하여 복잡한 애니메이션을 만들 수 있습니다. 예를 들어, 다음과 같은 요소들이 포함될 수 있습니다.

- 불꽃놀이
- 페이드 효과
- 롤인 또는 롤아웃
- 페이지 인 또는 페이지 아웃
- 객체 이동

이미 존재하는 자바스크립트 기반 애니메이션 라이브러리인 Script.Aculo.us에 관심이 있을 수 있습니다.

이 튜토리얼에서는 자바스크립트를 사용하여 애니메이션을 만드는 기본적인 방법을 설명합니다.

자바스크립트를 사용하여 DOM 요소(<img />, <div> 또는 기타 HTML 요소)를 논리적 방정식이나 함수에 따라 페이지 주위로 이동할 수 있습니다.

자바스크립트는 애니메이션 프로그램에서 자주 사용되는 다음 두 가지 함수를 제공합니다.

- `setTimeout(function, duration)` − 이 함수는 현재부터 duration 밀리초 후에 function을 호출합니다.
- `setInterval(function, duration)` − 이 함수는 매 duration 밀리초마다 function을 호출합니다.
- `clearTimeout(setTimeout_variable)` − 이 함수는 `setTimeout()` 함수로 설정된 타이머를 지웁니다.

자바스크립트는 또한 화면 상의 위치를 포함하여 DOM 객체의 여러 속성을 설정할 수 있습니다. 객체의 top 및 left 속성을 설정하여 화면의 어디에나 배치할 수 있습니다. 다음은 그 구문입니다.

```javascript
// 화면의 왼쪽 가장자리에서의 거리 설정
object.style.left = 'distance in pixels or points'; 

// 또는

// 화면의 상단 가장자리에서의 거리 설정
object.style.top = 'distance in pixels or points'; 
```

### 수동 애니메이션
다음과 같이 DOM 객체 속성과 자바스크립트 함수를 사용하여 간단한 애니메이션을 구현해 봅시다. 다음 목록에는 다양한 DOM 메서드가 포함되어 있습니다.

- 자바스크립트 함수 `getElementById()`를 사용하여 DOM 객체를 가져오고 이를 전역 변수 `imgObj`에 할당합니다.
- `imgObj`를 초기화하는 `init()` 함수를 정의하여 위치 및 왼쪽 속성을 설정합니다.
- 윈도우 로드 시 초기화 함수를 호출합니다.
- 마지막으로, `moveRight()` 함수를 호출하여 왼쪽 거리를 10픽셀 증가시킵니다. 음수 값을 설정하여 왼쪽으로 이동할 수도 있습니다.

### 예제

```html
<html>   
   <head>
      <title>JavaScript Animation</title>      
      <script type = "text/javascript">
         <!--
            var imgObj = null;
            
            function init() {
               imgObj = document.getElementById('myImage');
               imgObj.style.position = 'relative'; 
               imgObj.style.left = '0px'; 
            }
            function moveRight() {
               imgObj.style.left = parseInt(imgObj.style.left) + 10 + 'px';
            }
            
            window.onload = init;
         //-->
      </script>
   </head>
   
   <body>   
      <form>
         <img id = "myImage" src = "/images/html.gif" />
         <p>Click button below to move the image to right</p>
         <input type = "button" value = "Click Me" onclick = "moveRight();" />
      </form>      
   </body>
</html>
```

### 자동 애니메이션
위 예제에서는 이미지를 클릭할 때마다 오른쪽으로 이동하는 방법을 보았습니다. 이 프로세스를 자바스크립트 함수 `setTimeout()`을 사용하여 자동화할 수 있습니다.

여기서 우리는 몇 가지 메서드를 추가했습니다. 새로운 항목을 살펴봅시다.

- `moveRight()` 함수는 `setTimeout()` 함수를 호출하여 `imgObj`의 위치를 설정합니다.
- `setTimeout()` 함수로 설정된 타이머를 지우고 객체를 초기 위치에 설정하는 새로운 함수 `stop()`을 추가했습니다.

### 예제 코드

```html
<html>   
   <head>
      <title>JavaScript Animation</title>      
      <script type = "text/javascript">
         <!--
            var imgObj = null;
            var animate;
            
            function init() {
               imgObj = document.getElementById('myImage');
               imgObj.style.position = 'relative'; 
               imgObj.style.left = '0px'; 
            }
            function moveRight() {
               imgObj.style.left = parseInt(imgObj.style.left) + 10 + 'px';
               animate = setTimeout(moveRight, 20); // 20밀리초 후에 moveRight 호출
            }
            function stop() {
               clearTimeout(animate);
               imgObj.style.left = '0px'; 
            }
            
            window.onload = init;
         //-->
      </script>
   </head>
   
   <body>   
      <form>
         <img id = "myImage" src = "/images/html.gif" />
         <p>Click the buttons below to handle animation</p>
         <input type = "button" value = "Start" onclick = "moveRight();" />
         <input type = "button" value = "Stop" onclick = "stop();" />
      </form>      
   </body>
</html>
```

### 마우스 이벤트를 통한 롤오버
여기에는 마우스 이벤트를 사용하여 이미지 롤오버를 보여주는 간단한 예제가 있습니다.

다음 예제에서 사용된 내용을 살펴보겠습니다.

- 이 페이지를 로드할 때 'if' 문은 이미지 객체의 존재 여부를 확인합니다. 이미지 객체가 없는 경우, 이 블록은 실행되지 않습니다.
- `Image()` 생성자는 `image1`이라는 새로운 이미지 객체를 생성하고 미리 로드합니다.
- `src` 속성에 외부 이미지 파일 `/images/html.gif`의 이름을 할당합니다.
- 비슷하게, `image2` 객체를 생성하고 `/images/http.gif`를 이 객체에 할당했습니다.
- `#` (해시 기호)는 링크를 비활성화하여 클릭 시 브라우저가 URL로 이동하지 않도록 합니다. 이 링크는 이미지입니다.
- `onMouseOver` 이벤트 핸들러는 사용자의 마우스가 링크 위로 이동할 때 트리거되며, `onMouseOut` 이벤트 핸들러는 사용자의 마우스가 링크에서 벗어날 때 트리거됩니다.
- 마우스가 이미지 위로 이동하면, 첫 번째 이미지에서 두 번째 이미지로 HTTP 이미지가 변경됩니다. 마우스가 이미지에서 벗어나면, 원래 이미지가 다시 표시됩니다.

```html
<html>
   <head>
      <title>Rollover with a Mouse Events</title>
      <script type = "text/javascript">
         <!--
            if (document.images) {
               var image1 = new Image(); // 이미지를 미리 로드
               image1.src = "/images/html.gif";
               var image2 = new Image(); // 두 번째 이미지 미리 로드
               image2.src = "/images/http.gif";
            }
         //-->
      </script>
   </head>
   
   <body>
      <p>Move your mouse over the image to see the result</p>
      <a href = "#" onMouseOver = "document.myImage.src = image2.src;"
         onMouseOut = "document.myImage.src = image1.src;">
         <img name = "myImage" src = "/images/html.gif" />
      </a>
   </body>
</html>
```

---
## JavaScript - Multimedia

자바스크립트 `navigator` 객체는 `plugins`라는 자식 객체를 포함하고 있습니다. 이 객체는 브라우저에 설치된 각 플러그인에 대한 항목을 가진 배열입니다. `navigator.plugins` 객체는 Netscape, Firefox, Mozilla에서만 지원됩니다.

### 예제
다음은 브라우저에 설치된 모든 플러그인을 나열하는 방법을 보여주는 예제입니다.

```html
<html>
   <head>
      <title>List of Plug-Ins</title>
   </head>
   
   <body>
      <table border="1">
         <tr>
            <th>Plug-in Name</th>
            <th>Filename</th>
            <th>Description</th>
         </tr>
         
         <script language="JavaScript" type="text/javascript">
            for (i = 0; i < navigator.plugins.length; i++) {
               document.write("<tr><td>");
               document.write(navigator.plugins[i].name);
               document.write("</td><td>");
               document.write(navigator.plugins[i].filename);
               document.write("</td><td>");
               document.write(navigator.plugins[i].description);
               document.write("</td></tr>");
            }
         </script>
      </table>      
   </body>
</html>
```

### 플러그인 확인
각 플러그인은 배열에 항목을 가집니다. 각 항목은 다음 속성을 가지고 있습니다.

- `name` − 플러그인의 이름입니다.
- `filename` − 플러그인을 설치하는 데 사용된 실행 파일입니다.
- `description` − 개발자가 제공한 플러그인 설명입니다.
- `mimeTypes` − 플러그인이 지원하는 각 MIME 타입에 대한 항목을 가진 배열입니다.

이 속성들을 스크립트에서 사용하여 설치된 플러그인을 확인한 다음, 자바스크립트를 사용하여 적절한 멀티미디어 파일을 재생할 수 있습니다. 다음 예제를 참고하세요.

```html
<html>   
   <head>
      <title>Using Plug-Ins</title>
   </head>
   
   <body>   
      <script language="JavaScript" type="text/javascript">
         media = navigator.mimeTypes["video/quicktime"];
         
         if (media) {
            document.write("<embed src='quick.mov' height='100' width='100'>");
         } else {
            document.write("<img src='quick.gif' height='100' width='100'>");
         }
      </script>      
   </body>
</html>
```

**참고** − 여기서 우리는 HTML `<embed>` 태그를 사용하여 멀티미디어 파일을 임베드합니다.

### 멀티미디어 제어
다음은 거의 모든 브라우저에서 작동하는 실제 예제입니다.

```html
<html>   
   <head>
      <title>Using Embedded Object</title>
      
      <script type="text/javascript">
         <!--
            function play() {
               if (!document.demo.IsPlaying()) {
                  document.demo.Play();
               }
            }
            function stop() {
               if (document.demo.IsPlaying()) {
                  document.demo.StopPlay();
               }
            }
            function rewind() {
               if (document.demo.IsPlaying()) {
                  document.demo.StopPlay();
               }
               document.demo.Rewind();
            }
         //-->
      </script>
   </head>
   
   <body>      
      <embed id="demo" name="demo"
         src="http://www.amrood.com/games/kumite.swf"
         width="318" height="300" play="false" loop="false"
         pluginspage="http://www.macromedia.com/go/getflashplayer"
         swliveconnect="true">
      
      <form name="form" id="form" action="#" method="get">
         <input type="button" value="Start" onclick="play();" />
         <input type="button" value="Stop" onclick="stop();" />
         <input type="button" value="Rewind" onclick="rewind();" />
      </form>      
   </body>
</html>
```

---
## JavaScript - Debugging

개발자들은 코딩 중에 가끔 실수를 저지릅니다. 프로그램이나 스크립트의 실수를 버그라고 합니다.

버그를 찾고 수정하는 과정을 디버깅이라고 하며, 이는 개발 과정의 일상적인 부분입니다. 이 섹션에서는 디버깅 작업에 도움을 줄 수 있는 도구와 기술에 대해 다룹니다.

### IE에서의 오류 메시지

오류를 추적하는 가장 기본적인 방법은 브라우저에서 오류 정보를 켜는 것입니다. 기본적으로 Internet Explorer는 페이지에서 오류가 발생할 때 상태 표시줄에 오류 아이콘을 표시합니다.

#### 오류 아이콘

이 아이콘을 더블 클릭하면 발생한 특정 오류에 대한 정보를 보여주는 대화 상자가 나타납니다.

이 아이콘은 쉽게 간과될 수 있으므로, Internet Explorer는 오류가 발생할 때마다 자동으로 오류 대화 상자를 표시하는 옵션을 제공합니다.

이 옵션을 활성화하려면, `도구` → `인터넷 옵션` → `고급` 탭을 선택한 후, `스크립트 오류마다 알림 표시` 옵션을 선택하십시오.

#### 인터넷 옵션

### Firefox 또는 Mozilla에서의 오류 메시지

Firefox, Netscape, Mozilla와 같은 다른 브라우저는 오류 메시지를 JavaScript 콘솔 또는 오류 콘솔이라는 특수 창에 보냅니다. 콘솔을 보려면 `도구` → `웹 개발` → `오류 콘솔`을 선택하십시오.

불행히도, 이러한 브라우저는 오류가 발생했을 때 시각적 표시를 제공하지 않으므로, 콘솔을 열어두고 스크립트가 실행될 때 오류를 주시해야 합니다.

#### 오류 콘솔

### 오류 알림

콘솔 또는 Internet Explorer 대화 상자에 표시되는 오류 알림은 구문 및 런타임 오류의 결과입니다. 이러한 오류 알림에는 오류가 발생한 줄 번호가 포함됩니다.

Firefox를 사용하는 경우, 오류 콘솔에서 오류를 클릭하면 오류가 발생한 스크립트의 정확한 줄로 이동할 수 있습니다.

### 스크립트 디버깅 방법

자바스크립트를 디버깅하는 여러 가지 방법이 있습니다.

#### 자바스크립트 유효성 검사기 사용

자바스크립트 코드의 이상한 버그를 확인하는 한 가지 방법은 유효성을 검사하고 언어의 공식 구문 규칙을 따르는지 확인하는 프로그램을 통해 실행하는 것입니다. 이러한 프로그램은 유효성 검사 파서 또는 단순히 유효성 검사기라고 하며, 종종 상업적인 HTML 및 자바스크립트 편집기와 함께 제공됩니다.

가장 편리한 자바스크립트 유효성 검사기는 Douglas Crockford의 JavaScript Lint로, 무료로 제공됩니다. 단순히 해당 웹 페이지를 방문하여 제공된 텍스트 영역에 자바스크립트 코드를 붙여넣고 `jslint` 버튼을 클릭하면 됩니다. 이 프로그램은 자바스크립트 코드를 구문 분석하여 모든 변수 및 함수 정의가 올바른 구문을 따르는지 확인합니다. 또한 `if` 및 `while`과 같은 자바스크립트 문도 올바른 형식을 따르는지 확인합니다.

#### 프로그램에 디버깅 코드 추가

프로그램에 `alert()` 또는 `document.write()` 메서드를 사용하여 코드를 디버그할 수 있습니다. 예를 들어 다음과 같이 작성할 수 있습니다.

```javascript
var debugging = true;
var whichImage = "widget";

if( debugging )
   alert( "Calls swapImage() with argument: " + whichImage );
   var swapStatus = swapImage( whichImage );

if( debugging )
   alert( "Exits swapImage() with swapStatus=" + swapStatus );
```

`alert()`의 내용과 순서를 확인하여 프로그램의 상태를 쉽게 검사할 수 있습니다.

#### 자바스크립트 디버거 사용

디버거는 스크립트 실행의 모든 측면을 프로그래머의 제어 하에 두는 애플리케이션입니다. 디버거는 값 검사 및 설정뿐만 아니라 실행 흐름을 제어할 수 있는 인터페이스를 통해 스크립트 상태를 세밀하게 제어할 수 있습니다.

스크립트가 디버거에 로드되면 한 줄씩 실행하거나 특정 중단점에서 중지하도록 지시할 수 있습니다. 실행이 중지되면 프로그래머는 스크립트와 변수의 상태를 검사하여 문제가 있는지 여부를 확인할 수 있습니다. 또한 변수의 값 변경을 감시할 수 있습니다.

Mozilla 자바스크립트 디버거 (코드명 Venkman)의 최신 버전은 [http://www.hacksrus.com/~ginda/venkman](http://www.hacksrus.com/~ginda/venkman)에서 다운로드할 수 있습니다.

### 개발자를 위한 유용한 팁

스크립트의 오류 수를 줄이고 디버깅 과정을 단순화하기 위해 다음 팁을 기억하십시오.

- **주석을 많이 사용하십시오.** 주석은 스크립트를 작성한 이유와 특히 어려운 코드 섹션을 설명할 수 있게 해줍니다.
- **항상 들여쓰기를 사용하여 코드를 읽기 쉽게 만드십시오.** 들여쓰기는 시작 및 종료 태그, 중괄호 및 기타 HTML 및 스크립트 요소를 일치시키는 데 도움이 됩니다.
- **모듈식 코드 작성.** 가능한 경우 문을 함수로 그룹화하십시오. 함수는 관련된 문을 그룹화하고, 최소한의 노력으로 코드의 일부를 테스트하고 재사용할 수 있습니다.
- **변수와 함수 이름을 일관되게 사용하십시오.** 충분히 의미가 있고 변수의 내용이나 함수의 목적을 설명하는 이름을 사용해 보십시오.
- **일관된 구문 사용.** 변수 및 함수 이름을 지정할 때 일관된 구문을 사용하십시오. 모두 소문자 또는 모두 대문자로 사용하거나, Camel-Back 표기법을 선호하는 경우 일관되게 사용하십시오.
- **긴 스크립트를 모듈 방식으로 테스트하십시오.** 즉, 스크립트 전체를 작성하기 전에 부분적으로 작성하고 작동하도록 만드십시오.
- **설명적인 변수 및 함수 이름 사용.** 단일 문자 이름 사용을 피하십시오.
- **따옴표에 주의하십시오.** 따옴표는 문자열 주위에 쌍으로 사용되며 두 따옴표는 같은 스타일이어야 합니다(싱글 또는 더블).
- **등호에 주의하십시오.** 비교 목적으로 단일 `=`를 사용하지 않아야 합니다.
- **변수를 명시적으로 선언하십시오.** `var` 키워드를 사용하십시오.

---
## JavaScript - Image Map


자바스크립트를 사용하여 클라이언트 측 이미지 맵을 만들 수 있습니다. 클라이언트 측 이미지 맵은 `<img />` 태그의 usemap 속성과 특별한 `<map>` 및 `<area>` 확장 태그를 사용하여 활성화됩니다.

맵을 구성할 이미지는 일반적으로 `<img />` 요소를 사용하여 페이지에 삽입되며, usemap이라는 추가 속성을 포함합니다. usemap 속성의 값은 곧 만나게 될 `<map>` 요소의 name 속성 값 앞에 해시 기호(#)를 붙인 것입니다.

`<map>` 요소는 실제로 이미지를 위한 맵을 생성하며, 일반적으로 `<img />` 요소 바로 뒤에 위치합니다. `<map>` 요소는 실제로 클릭 가능한 핫스팟을 정의하는 `<area />` 요소들을 포함하는 컨테이너 역할을 합니다. `<map>` 요소는 맵을 식별하는 이름을 나타내는 name 속성만을 가집니다. 이것이 `<img />` 요소가 어떤 `<map>` 요소를 사용할지 알 수 있는 방법입니다.

`<area>` 요소는 각 클릭 가능한 핫스팟의 경계를 정의하는 형태와 좌표를 지정합니다.

다음 코드는 이미지 맵과 자바스크립트를 결합하여 이미지의 다른 부분에 마우스를 이동할 때 텍스트 상자에 메시지를 표시하는 예제입니다.

```html
<html>   
   <head>
      <title>Using JavaScript Image Map</title>
      
      <script type = "text/javascript">
         <!--
            function showTutorial(name) {
               document.myform.stage.value = name
            }
         //-->
      </script>
   </head>
   
   <body>
      <form name = "myform">
         <input type = "text" name = "stage" size = "20" />
      </form>
      
      <!-- 맵 생성 -->
      <img src = "/images/usemap.gif" alt = "HTML Map" border = "0" usemap = "#tutorials"/>
      
      <map name = "tutorials">
         <area shape="poly" 
            coords = "74,0,113,29,98,72,52,72,38,27"
            href = "/perl/index.htm" alt = "Perl Tutorial"
            target = "_self" 
            onMouseOver = "showTutorial('perl')" 
            onMouseOut = "showTutorial('')"/>
         
         <area shape = "rect" 
            coords = "22,83,126,125"
            href = "/html/index.htm" alt = "HTML Tutorial" 
            target = "_self" 
            onMouseOver = "showTutorial('html')" 
            onMouseOut = "showTutorial('')"/>
         
         <area shape = "circle" 
            coords = "73,168,32"
            href = "/php/index.htm" alt = "PHP Tutorial"
            target = "_self" 
            onMouseOver = "showTutorial('php')" 
            onMouseOut = "showTutorial('')"/>
      </map>
   </body>
</html>
```

출력

이미지 객체에 마우스 커서를 올려놓으면 맵의 개념을 느낄 수 있습니다.

---
## JavaScript - Browsers Compatibility

다양한 브라우저 간의 차이를 이해하는 것은 각 브라우저가 예상하는 방식으로 웹 페이지를 처리할 수 있도록 하는 데 중요합니다. 따라서 웹 페이지가 실행되는 브라우저를 아는 것이 중요합니다.

웹 페이지가 현재 실행되고 있는 브라우저에 대한 정보를 얻으려면 내장된 navigator 객체를 사용합니다.

### Navigator 속성

웹 페이지에서 사용할 수 있는 몇 가지 Navigator 관련 속성이 있습니다. 다음은 각 속성의 이름과 설명 목록입니다.

| Sr.No. | 속성 및 설명 |
| ------ | ------------- |
| 1      | **appCodeName**<br>이 속성은 브라우저의 코드 이름을 포함하는 문자열입니다. 예를 들어 Netscape의 경우 Netscape, Microsoft Internet Explorer의 경우 Internet Explorer입니다. |
| 2      | **appVersion**<br>이 속성은 브라우저의 버전뿐만 아니라 언어 및 호환성과 같은 유용한 정보를 포함하는 문자열입니다. |
| 3      | **language**<br>이 속성은 브라우저에서 사용되는 언어의 두 글자 약어를 포함합니다. (Netscape 전용) |
| 4      | **mimTypes[]**<br>이 속성은 클라이언트가 지원하는 모든 MIME 유형을 포함하는 배열입니다. (Netscape 전용) |
| 5      | **platform**<br>이 속성은 브라우저가 컴파일된 플랫폼을 포함하는 문자열입니다. 예를 들어, 32비트 Windows 운영 체제의 경우 "Win32"입니다. |
| 6      | **plugins[]**<br>이 속성은 클라이언트에 설치된 모든 플러그인을 포함하는 배열입니다. (Netscape 전용) |
| 7      | **userAgent[]**<br>이 속성은 브라우저의 코드 이름과 버전을 포함하는 문자열입니다. 이 값은 클라이언트를 식별하기 위해 원본 서버로 전송됩니다. |

### Navigator 메서드

몇 가지 Navigator 특정 메서드가 있습니다. 여기에는 이름과 설명 목록이 있습니다.

| Sr.No. | 설명 |
| ------ | ---- |
| 1      | **javaEnabled()**<br>이 메서드는 클라이언트에서 자바스크립트가 활성화되어 있는지 확인합니다. 자바스크립트가 활성화되어 있으면 이 메서드는 true를 반환하고, 그렇지 않으면 false를 반환합니다. |
| 2      | **plugings.refresh**<br>이 메서드는 새로 설치된 플러그인을 사용할 수 있게 하고, plugins 배열을 모든 새 플러그인 이름으로 채웁니다. (Netscape 전용) |
| 3      | **preference(name, value)**<br>이 메서드는 서명된 스크립트가 일부 Netscape 기본 설정을 가져오고 설정할 수 있도록 합니다. 두 번째 매개변수가 생략되면 이 메서드는 지정된 기본 설정 값을 반환하고, 그렇지 않으면 값을 설정합니다. (Netscape 전용) |
| 4      | **taintEnabled()**<br>이 메서드는 데이터 오염이 활성화된 경우 true를 반환하고, 그렇지 않은 경우 false를 반환합니다. |

### 브라우저 감지

브라우저 이름을 찾아내고 그에 따라 HTML 페이지를 사용자에게 제공하는 간단한 자바스크립트가 있습니다.

```html
<html>   
   <head>
      <title>Browser Detection Example</title>
   </head>
   
   <body>      
      <script type = "text/javascript">
         <!--
            var userAgent   = navigator.userAgent;
            var opera       = (userAgent.indexOf('Opera') != -1);
            var ie          = (userAgent.indexOf('MSIE') != -1);
            var gecko       = (userAgent.indexOf('Gecko') != -1);
            var netscape    = (userAgent.indexOf('Mozilla') != -1);
            var version     = navigator.appVersion;
            
            if (opera) {
               document.write("Opera based browser");
               // Opera 전용 URL을 여기에 작성합니다.
            } else if (gecko) {
               document.write("Mozilla based browser");
               // Gecko 전용 URL을 여기에 작성합니다.
            } else if (ie) {
               document.write("IE based browser");
               // IE 전용 URL을 여기에 작성합니다.
            } else if (netscape) {
               document.write("Netscape based browser");
               // Netscape 전용 URL을 여기에 작성합니다.
            } else {
               document.write("Unknown browser");
            }
            
            // 위 조건과 함께 버전도 포함시킬 수 있습니다.
            document.write("<br /> Browser version info : " + version );
         //-->
      </script>      
   </body>
</html>
```

### 출력

이 스크립트는 브라우저를 감지하여 사용자가 사용하는 브라우저에 따라 적절한 메시지를 표시합니다.


---
## 출처
 - [Tutorialspoint JavaScript - Quick Guide](https://www.tutorialspoint.com/javascript/javascript_quick_guide.htm)
---
## [다음](./07_CSharp_기초.md)